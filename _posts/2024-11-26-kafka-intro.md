---
layout : single
title : "[MSA] kafka 개요"
categories: MSA
tag : [MSA, SpringCloud, kafka]
author_profile: true
---

📌 개인적인 공간으로 공부를 기록하고 복습하기 위해 사용하는 블로그입니다. <br>
정확하지 않은 정보가 있을 수 있으니 참고바랍니다 :😸 <br>
[틀린 내용은 댓글로 남겨주시면 복받으실거에요]  
{: .notice--primary}

인프런 Dowon Lee님의 Spring Cloud로 개발하는 마이크로서비스 애플리케이션(MSA) 강의를 듣고 정리한 내용입니다.😊<br>
[Spring Cloud로 개발하는 마이크로서비스 애플리케이션(MSA) 강의 들으러 가기👩‍🏫](https://inf.run/GHeRm)
{: .notice--warning}


# Apache Kafka: 고성능 메시지 브로커의 이해

Apache Kafka는 **Apache Software Foundation**에서 Scala 언어로 개발된 오픈 소스 메시징 프로젝트이고,<br> 
높은 처리량과 낮은 지연 시간을 제공하여 실시간 데이터 피드를 관리할 수 있는 플랫폼으로 널리 사용되고 있다.

### 메시지 브로커

- **메시지 브로커**는 한 시스템에서 다른 시스템으로 메시지를 전달할 때 사용되는 서버
- 메시지는 일반적인 텍스트뿐만 아니라 JSON, XML, Java 객체 등 다양한 형태의 데이터를 포함할 수 있다.
- 메시지 브로커를 통해 송신자와 수신자를 분리하여 데이터 전달의 안정성과 효율성을 높일 수 있다.

## Apache Kafka의 역사

- Kafka는 원래 링크드인(LinkedIn)에서 개발
- 2011년에 오픈 소스로 공개되었으며, 현재는 Apache Software Foundation에서 관리
- 2014년에는 Kafka 개발자들이 컨플루언트(Confluent)라는 회사를 설립하여 Kafka의 개발과 서비스를 전문적으로 제공하고 있다.
    
### kafka 등장 이전과 이후
    
1. **등장 이전** : 기존 시스템의 문제점 
        
    <img src= "https://github.com/user-attachments/assets/05219d38-6231-4db1-a830-8661817e0249" width=500/>
        
    Kafka 이전에는 각 시스템이 직접 연결되어 데이터를 주고받는 **엔드 투 엔드(End-to-End)** 방식이 일반적이었다. 이 방식은 다음과 같은 문제점을 가지고 있다
        
    - **복잡한 데이터 연동 구조**: 각 시스템마다 다른 데이터 파이프라인과 포맷을 유지해야 하므로 개발과 유지 보수가 어렵다.
    - **확장성의 한계**: 시스템이 복잡해질수록 확장이 어렵다.
    - **장애 민감성**: 하드웨어나 운영체제의 특성에 따라 장애에 민감하게 반응할 수 있다.
2. **등장 이후**
        
    <img src= "https://github.com/user-attachments/assets/a18024b9-b7e0-4bb9-ad06-1ccdc608147a" width=500/>
        
    이러한 문제점을 해결하기 위해 Kafka가 등장
        
    - **단일 인터페이스 제공**: 모든 데이터 송신자는 Kafka로만 데이터를 보내고, 수신자는 Kafka에서 데이터를 받습니다.
    - **확장성 향상**: 클러스터링을 통해 여러 대의 브로커로 구성하여 스케일링이 가능합니다.
    - **높은 처리량과 낮은 지연 시간**: 메시지를 최적화된 방식으로 저장하고 처리하여 고성능을 제공합니다.
    - **다양한 에코시스템 연동**: 스트리밍 서비스, SQL 기반 질의 등 다양한 기능과 연동할 수 있습니다.

## Kafka의 주요 구성 요소

### 1. Kafka 브로커

실행된 kafka 애플리케이션 서버를 말한다.

- **역할**: 메시지를 저장하고 관리하는 서버로, Kafka 클러스터를 구성
- **구성**: 일반적으로 3대 이상의 브로커로 클러스터를 구성하는 것을 권장한다.
- **장점**: 브로커 간의 메시지 복제를 통해 한 대의 서버에 문제가 발생하더라도 다른 브로커가 역할을 대체할 수 있어 안정성이 높다.

### 2. ZooKeeper

- **역할**
    - Kafka 브로커를 관리하고 조율하는 **코디네이터** 역할
    - 메타 데이터 (Broker Id, Controller ID) 등을 저장한다.
    - Controller 정보를 저장한다.
        >  📌
            - n개의 Borker 중 1 대는 Controller 기능을 수행 <br>
            - **Controller의 역할** : 각 Broker에게 담당 파티션 할당 수행 / Broker 정상 동작 모니터링 관리
            
        
- **기능**:
    - 브로커의 상태 관리
    - 리더 브로커 선출
    - 장애 발생 시 브로커의 상태 조정 및 복구
- **구성**: Kafka는 ZooKeeper와 함께 동작하여 클러스터의 메타데이터와 상태를 관리한다.

## RabbitMQ

- 메세지 큐잉 서버
- 용량적인 측면이라던가 안정성 측면에서 kafka가 대용량 시스템에서 더 많이 사용되고 있다.

### Kafka와 RabbitMQ의 비교

| 특징 | Apache Kafka | RabbitMQ |
| --- | --- | --- |
| 메시징 모델 | 게시-구독(Publish-Subscribe) 모델 | 메시지 큐잉(Message Queuing) 및 게시-구독 모델 |
| 처리량 | 초당 수백만 건의 메시지 처리 가능 | 중간 정도의 처리량 지원 |
| 지연 시간 | 낮은 지연 시간 | 비교적 낮은 지연 시간 |
| 영속성 | 디스크에 메시지 저장, 로그 기반 저장 방식 | 메모리 및 디스크에 메시지 저장, 메시지 확인 및 영속성 옵션 제공 |
| 메시지 순서 보장 | 파티션 내에서만 순서 보장 | FIFO(First-In-First-Out) 큐로 순서 보장 가능 |
| 확장성 | 브로커 추가를 통한 수평 확장 용이 | 클러스터링 지원하지만 확장성은 Kafka보다 제한적 |
| 프로토콜 | 전용 TCP 기반 프로토콜 | AMQP, MQTT, STOMP 등 다양한 프로토콜 지원 |
| 사용 사례 | 로그 수집, 실시간 스트리밍, 이벤트 소싱, 대용량 데이터 처리 | 작업 대기열, 비동기 처리, 마이크로서비스 간 통신, RPC 구현 |

---

Apache Kafka는 현대의 데이터 중심 애플리케이션에서 필수적인 역할을 하는 고성능 메시지 브로커이다. <br>
기존 시스템의 복잡한 데이터 연동 문제를 해결하고, 확장성과 안정성을 제공하여 다양한 산업 분야에서 활용되고 있다. <br>
Kafka를 도입함으로써 데이터 파이프라인을 단순화하고, 실시간으로 대용량 데이터를 처리하여 비즈니스 가치를 극대화할 수 있다. <br>
앞으로도 Kafka는 빅데이터와 실시간 처리의 핵심 기술로서 그 중요성이 더욱 부각될 것 같다. 

<br>
<br>
<br>
<br>
