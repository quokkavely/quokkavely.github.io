---
layout : single
title : "[MSA] 강의 내용과 실제 구현의 차이: API Gateway JWT 인증 처리 방식 비교"
categories: MSA
tag : [MSA, SpringCloud]
author_profile: true
---

📌 개인적인 공간으로 공부를 기록하고 복습하기 위해 사용하는 블로그입니다. <br>
정확하지 않은 정보가 있을 수 있으니 참고바랍니다 :😸 <br>
[틀린 내용은 댓글로 남겨주시면 복받으실거에요]  
{: .notice--primary}

인프런 Dowon Lee님의 Spring Cloud로 개발하는 마이크로서비스 애플리케이션(MSA) 강의를 듣고 정리한 필기입니다.😊<br>
[Spring Cloud로 개발하는 마이크로서비스 애플리케이션(MSA) 강의 들으러 가기👩‍🏫](https://inf.run/GHeRm)
{: .notice--warning}

<br>

## 강의 내용과 실제 구현의 차이: 실무에서의 Spring Cloud Gateway 활용과 JWT 인증 처리 방식 비교

[어제 강의](https://quokkavely.github.io/msa/gateway)에서 배운 기본적인 설정과 프로젝트에서 구현한 방식에 여러 차이가 있음을 발견했다. 경로 재작성, JWT 인증 방식, 환경 변수 활용 등 실무에서 주로 사용하는 설정과 강의에서 배운 방식 간의 차이를 비교해보고 이를 통해 API Gateway 구성 방식에 대한 이해도를 높이기 위해서 프로젝트랑 강의랑 어떤 부분에서 차이가 있었는지 정리해봤다.

1. 경로 재작성 및 서비스 분리
    - **강의 내용**
        
        강의에서는 기본적인 라우팅 설정을 통해 Gateway가 클라이언트 요청을 각 마이크로서비스로 전달하는 방식만 설명했다. 일반적으로는 특정 경로(/user-service/**)를 설정하고, 클라이언트가 해당 경로로 요청을 보낼 때 각 서비스로 전달하는 기본적인 구조를 설명한다.
        
    - **실제 구현**
        
        실제 프로젝트에서는 rewritePath 필터를 활용해 공통 경로를 제거하는 방식으로 구성했다. 예를 들어, /auth/** 경로로 들어온 요청에서 /auth/ 부분을 제거하여 마이크로서비스의 실제 엔드포인트에 맞게 경로를 간소화했다. 이렇게 하면 각 서비스의 엔드포인트가 복잡해지지 않으며, API URI가 간결해지는 효과를 얻을 수 있다. 이는 실무에서 자주 사용하는 방식으로, 마이크로서비스 엔드포인트를 직관적이고 관리하기 쉽게 만들어준다.
        
2. 보호 경로와 공개 경로의 분리
    - **강의 내용**
        
        강의에서는 보통 모든 요청을 동일한 방식으로 처리하거나 간단한 인증을 추가하는 예시만 보여준다. 경로에 따라 인증을 나누기보다는 기본적인 인증 절차만 적용하는 경우가 많았다.
        
    - **실제 구현**
        
        공개 경로와 보호 경로를 분리하여 RouteLocatorConfig에서 각각 다른 설정을 추가했다. 예를 들어, /auth/signup과 /auth/login 경로는 공개 API로, 인증 없이 접근 가능하도록 설정했다. 반면, /auth/**와 같은 보호 경로는 JWT 검증 필터를 거치도록 설정하여, 인증된 사용자만 접근할 수 있게 했다. 이 방식은 보안이 필요한 API와 일반 API를 명확히 구분해 관리하기 편리하며, 서비스 보안을 강화하는 데 도움이 된다.
        
3. JWT 필터 구현 방식
    - **강의 내용**
        
        강의에서는 기본적인 JWT 검증을 설명하거나, 간단하게 Gateway에서 토큰 검증을 수행하는 방식만 소개하는 경우가 많았다. 일반적으로 토큰 유효성을 체크하는 단순한 예시를 제공하지만, 세부적인 유효성 검사나 에러 처리에 대해서는 깊이 다루지 않는다.
        
    - **실제 구현**
        
        JwtFilter에서는 요청 경로에 따라 JWT 검증 여부를 구분하고, 각 요청에 대해 토큰의 서명과 만료 여부를 정밀하게 검증했다. 예를 들어, JWT 토큰의 서명이 올바른지, 만료되지 않았는지 등을 확인하며, 유효하지 않은 토큰이 포함된 요청은 일관된 에러 메시지와 함께 즉시 반환하도록 설정했다. 이렇게 함으로써, 실무 환경에서 자주 요구되는 구체적인 인증 처리와 에러 처리가 가능하다.
        
4. 환경 변수 및 JWT 키 관리 방식
    - **강의 내용**
        
        강의에서는 JWT 비밀 키(token.secret)를 코드 내에 하드코딩하여, 쉽게 설명하고 빠르게 설정할 수 있도록 했다. 기본 설정과 빠른 실습을 위해 이 방법을 자주 사용하지만, 보안에는 취약할 수 있다.
        
    - **실제 구현**
        
        실제 프로젝트에서는 token.secret 값을 환경 변수나 외부 설정 파일로 관리해 보안성을 강화했다. JwtUtils 클래스는 환경 변수에서 직접 token.secret 키를 가져와 사용하므로, 강의에서 하드코딩 방식보다 보안에 유리하다. 또한, 환경 변수나 설정 파일을 통해 민감한 정보를 관리하면 배포 환경에 맞게 쉽게 변경할 수 있어 유지보수가 편리하다.
        

---

현재 프로젝트 api-gateway를 조금 develope해보고자 정리해보았는데(안되거나 예외처리가 부족한 부분이 더러 있음), 시간이 꽤나 오래걸릴 것 같다..! 그래도 비슷한 부분이 있어서 잘 정리해서 내 것으로 만들어야지
이외에도 feign client 통신 부분도 다시 공부해서 수정할 예정이다.


<br>
<br>
<br>
<br>

