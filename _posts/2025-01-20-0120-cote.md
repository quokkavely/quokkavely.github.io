---
layout : single
title : "[Java]í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ Lv2_[1ì°¨]ìºì‹œ ( LRU, LinkedHashMap)"
categories: Programmers
tag : [CodingTest, ì‹¤ìŠµ]
author_profile: true
---

ğŸ“Œ ê°œì¸ì ì¸ ê³µê°„ìœ¼ë¡œ ê³µë¶€ë¥¼ ê¸°ë¡í•˜ê³  ë³µìŠµí•˜ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. <br>
ì •í™•í•˜ì§€ ì•Šì€ ì •ë³´ê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë‹ˆ ì°¸ê³ ë°”ëë‹ˆë‹¤ :ğŸ˜¸ <br>
[í‹€ë¦° ë‚´ìš©ì€ ëŒ“ê¸€ë¡œ ë‚¨ê²¨ì£¼ì‹œë©´ ë³µë°›ìœ¼ì‹¤ê±°ì—ìš”]  
{: .notice--primary}


# í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ Lv2. 1ì°¨ ìºì‹œ

[í’€ì–´ë³´ê¸°ğŸ”—: [1ì°¨]ìºì‹œ](https://school.programmers.co.kr/learn/courses/30/lessons/17680)

## ë¬¸ì œ í’€ì´

```java
import java.util.*;
class Solution {
    public int solution(int cacheSize, String[] cities) {
        int answer = 0;
        
        Map<String, Integer> map = new HashMap<>();
        
        for(String c : cities) {
            map.put(c, map.getOrDefault(c, 0) + 1 );
        }
        
        List<String> list = new ArrayList<>(map.keySet());
        
        //value ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì •ë ¬
        list.sort((o1, o2) -> map.get(o2).compareTo(map.get(o1)));
        
        
        //ì—­ìˆœìœ¼ë¡œ ì •ë ¬ í–ˆì„ ë•Œ ìºì‹œ ë‚´ëŠ” 1 , ì•„ë‹ˆë©´ 5ì¸ë°
        //mapì— ê°œìˆ˜-1 ë§Œí¼ ì €ì¥ë˜ì–´ìˆìœ¼ë‹ˆê¹Œ
        //value * ì‹¤í–‰ì‹œê°„
        
        List<String> hit = new ArrayList<>();
        
        // cache hit
        for(int i = 0 ; i < cacheSize ; i++) {
            hit.add(list.get(i));
        }
        
        for(String s : map.keySet()) {
           if(hit.contains(s)) {
               answer += map.get(s) * 1;
           } else {
               answer += map.get(s) * 5;
           }
        }
        
        return answer;
    }
}
```

ì´ë ‡ê²Œ í’€ì—ˆëŠ”ë° í…ŒìŠ¤íŠ¸ ì½”ë“œ ì‹¤í–‰í•˜ë‹ˆê¹Œ ë‹¤ í‹€ë ¸ê³ ,, ë‚´ê°€ ìƒê°í•œ ê³„ì‚°ê³¼ëŠ” ì¼ì¹˜í•´ì„œ LFUë¥¼ ëª°ë¼ì„œ í‹€ë¦¬ëŠ” ì´ìœ  ê°™ì•˜ë‹¤. ê²€ìƒ‰í•´ë„ ì´í•´ê°€ ì˜ ì•ˆ ê°€ì„œ ê°€ì§€ê³  ìˆëŠ” CS ì±… ì°¾ì•„ë´¤ëŠ”ë° ê±°ê¸°ì—ë„ LFUëŠ” ì—†ëŠ”â€¦ã… ã… ã… â€¦

ë‚´ê°€ ëŒ€ì¶© ì´í•´í•˜ê¸°ë¡œëŠ” ì˜¤ë˜ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê±¸ ë¨¼ì € ì œê±°í•œë‹¤ëŠ” ëœ»ì¸ ê²ƒ ê°™ì€ë° ì•„ë¬´ë˜ë„ ìºì‹œê°€ ê½‰ ì°¬ ê²½ìš° ê°€ì¥ ì˜¤ë˜ëœ ë°ì´í„°ë¥¼ ì œê±°í•˜ëŠ” ë¡œì§ìœ¼ë¡œ ì´í•´í–ˆë‹¤.

ê·¸ë˜ì„œ í˜„ì¬ map êµ¬ì¡°ì—ì„œ LinkedHashMap êµ¬ì¡°ë¥¼ ì‚¬ìš©í•´ì£¼ì–´ì•¼ í•œë‹¤ (ìë°”ì˜ ì •ì„ì—ì„œ ì•„ë˜ ë‚´ìš©ì„ ìª¼ê·¸ë§£ê²Œ ì°¾ì•„ë³¼ ìˆ˜ ìˆì—ˆë‹¤..)

Setì´ ì•„ë‹Œ Mapì„ ì‚¬ìš© í•´ì•¼ í•˜ëŠ” ì´ìœ 

- LinkedHashSetë„ ìˆì§€ë§Œ, `Set`ì€ ìˆœì„œë¥¼ ë³´ì¥í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ, ê°€ì¥ ì˜¤ë˜ëœ í•­ëª©ì„ ì°¾ê±°ë‚˜ ì‚­ì œí•  ìˆ˜ ì—†ë‹¤.
- ë˜í•œ ìºì‹œ í¬ê¸° ì œí•œì„ êµ¬í˜„ í•˜ê¸° ì–´ë ¤ì›€ > ìºì‹œ í¬ê¸° ì´ˆê³¼ ì‹œ ì˜¤ë˜ëœ í•­ëª©ì„ ìë™ìœ¼ë¡œ ì‚­ì œí•˜ëŠ” ê¸°ëŠ¥ì´ ì—†ë‹¤.

> **LinkedHashMap, LinkedHashSet**
HashMapê³¼ HashSetì— ì €ì¥ ìˆœì„œ ìœ ì§€ ê¸°ëŠ¥ì„ ì¶”ê°€
> 

## LinkedHashMap ì´ë€?

ì•„ë˜ì˜ ê²½ìš°ì— ì£¼ë¡œ ì‚¬ìš©ëœë‹¤.

- **LRU ìºì‹œ êµ¬í˜„**: ì œí•œëœ í¬ê¸°ì˜ ìºì‹œì—ì„œ ê°€ì¥ ì˜¤ë˜ëœ í•­ëª©ì„ êµì²´í•´ì•¼ í•˜ëŠ” ê²½ìš°
- **ìˆœì„œ ê¸°ë°˜ ë°ì´í„° ì €ì¥**: ì‚½ì… ìˆœì„œë‚˜ ì ‘ê·¼ ìˆœì„œì— ë”°ë¼ ë°ì´í„°ë¥¼ ê´€ë¦¬í•´ì•¼ í•˜ëŠ” ê²½ìš°

### ìƒì„±

1. ê¸°ë³¸ ìƒì„±
    
    ```java
    LinkedHashMap<K, V> map = new LinkedHashMap<>();
    ```
    
2. ì´ˆê¸° ìš©ëŸ‰, ë¶€í•˜ìœ¨ ì„¤ì • ìƒì„±ì
    
    ```java
    LinkedHashMap<K, V> map = new LinkedHashMap<>(int initialCapacity, float loadFactor);
    ```
    
3. ì ‘ê·¼ ìˆœì„œ ì„¤ì • ìƒì„±ì
    
    ```java
    LinkedHashMap<K, V> map = new LinkedHashMap<>(int initialCapacity, float loadFactor, boolean accessOrder);
    ```
    
    - `initialCapacity`: ì´ˆê¸° ìš©ëŸ‰ (ê¸°ë³¸ê°’ 16)
    - `loadFactor`: ë¶€í•˜ìœ¨, ìš©ëŸ‰ì´ ì´ˆê³¼ë˜ê¸° ì „ì— ë²„í‚·ì„ ì¬ì¡°ì •í•˜ëŠ” ë¹„ìœ¨ (ê¸°ë³¸ê°’ 0.75)
    - `accessOrder`ê°€ `true`ì´ë©´ ì ‘ê·¼ ìˆœì„œë¥¼ ìœ ì§€í•©ë‹ˆë‹¤. ì¦‰, ê°€ì¥ ìµœê·¼ì— ì ‘ê·¼í•œ ì—”íŠ¸ë¦¬ê°€ ë’¤ë¡œ ì´ë™
    - `false`ì¼ ê²½ìš° ê¸°ë³¸ì ìœ¼ë¡œ ì‚½ì… ìˆœì„œë¥¼ ìœ ì§€

### LRU êµ¬í˜„ì˜ í•µì‹¬: `removeEldestEntry`

`LinkedHashMap`ì„ ì‚¬ìš©í•˜ë©´, `removeEldestEntry(Map.Entry<K,V> eldest)` ë©”ì„œë“œë¥¼ ì˜¤ë²„ë¼ì´ë“œí•˜ì—¬ ê°€ì¥ ì˜¤ë˜ëœ í•­ëª©(ì¦‰, ì²˜ìŒì— ì‚½ì…ëœ í•­ëª©)ì„ ì‚­ì œí•˜ëŠ” ì¡°ê±´ì„ ì •ì˜í•  ìˆ˜ ìˆë‹¤.

```java
class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int cacheSize;

    public LRUCache(int cacheSize) {
        super(cacheSize, 0.75f, true); // ì ‘ê·¼ ìˆœì„œë¥¼ ìœ ì§€
        this.cacheSize = cacheSize;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > cacheSize; // ìºì‹œ í¬ê¸°ë¥¼ ì´ˆê³¼í•˜ë©´ ê°€ì¥ ì˜¤ë˜ëœ í•­ëª© ì‚­ì œ
    }
}
```

- `size() > cacheSize`: í˜„ì¬ ìºì‹œ í¬ê¸°ê°€ ì œí•œ í¬ê¸°ë¥¼ ì´ˆê³¼í•˜ë©´ `true`ë¥¼ ë°˜í™˜í•˜ì—¬ ê°€ì¥ ì˜¤ë˜ëœ í•­ëª©ì„ ì œê±°í•œë‹¤.
- ì´ë ‡ê²Œ í•˜ë©´ ìºì‹œê°€ í•­ìƒ ì œí•œëœ í¬ê¸°ë¥¼ ìœ ì§€í•˜ë©´ì„œ LRU ë™ì‘ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.

### ì˜ˆì œ

1. **LRU :** `removeEldestEntry`  í™œìš©
    
    ```java
    import java.util.LinkedHashMap;
    import java.util.Map;
    
    public class LRUExample {
        public static void main(String[] args) {
            Map<Integer, String> cache = new LinkedHashMap<>(3, 0.75f, true) {
                @Override
                protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
                    return size() > 3; // 3ê°œ ì´ˆê³¼ ì‹œ ê°€ì¥ ì˜¤ë˜ëœ í•­ëª© ì œê±°
                }
            };
    
            cache.put(1, "A");
            cache.put(2, "B");
            cache.put(3, "C");
    
            System.out.println(cache); // ì¶œë ¥: {1=A, 2=B, 3=C}
    
            cache.get(1); // 1ë²ˆ ì ‘ê·¼
            cache.put(4, "D"); // ìºì‹œ í¬ê¸° ì´ˆê³¼ -> ê°€ì¥ ì˜¤ë˜ëœ 2ë²ˆ ì œê±°
    
            System.out.println(cache); // ì¶œë ¥: {3=C, 1=A, 4=D}
        }
    }
    ```
    
    - ìºì‹œê°€ 3ê°œë¥¼ ì´ˆê³¼í•˜ë©´ ê°€ì¥ ì˜¤ë˜ëœ í•­ëª©ì„ ì œê±°
    - `get(1)`ì„ í˜¸ì¶œí–ˆìœ¼ë¯€ë¡œ, 1ë²ˆì´ ê°€ì¥ ìµœê·¼ì— ì ‘ê·¼ëœ í•­ëª©ìœ¼ë¡œ ì´ë™
    - 4ë²ˆì„ ì¶”ê°€í•˜ë©´, ê°€ì¥ ì˜¤ë˜ëœ 2ë²ˆì´ ì œê±°ëœë‹¤.
2. **LRU ì™€ FIFO**
    
    ```java
    import java.util.LinkedHashMap;
    
    public class TestLinkedHashMap {
        public static void main(String[] args) {
            // LRU: ì ‘ê·¼ ìˆœì„œ ìœ ì§€
            LinkedHashMap<Integer, String> lru = new LinkedHashMap<>(3, 0.75f, true);
    
            // FIFO: ì‚½ì… ìˆœì„œ ìœ ì§€
            LinkedHashMap<Integer, String> fifo = new LinkedHashMap<>(3, 0.75f, false);
    
            lru.put(1, "A");
            lru.put(2, "B");
            lru.put(3, "C");
            lru.get(1); // ì ‘ê·¼ ìˆœì„œ ê°±ì‹ 
    
            fifo.put(1, "A");
            fifo.put(2, "B");
            fifo.put(3, "C");
            fifo.get(1); // ì‚½ì… ìˆœì„œ ìœ ì§€
    
            System.out.println("LRU: " + lru); // {2=B, 3=C, 1=A}
            System.out.println("FIFO: " + fifo); // {1=A, 2=B, 3=C}
        }
    }
    
    ```
    

### ì¥ì 

- **ì†ì‰¬ìš´ LRU êµ¬í˜„**: `LinkedHashMap`ê³¼ `removeEldestEntry`ë¥¼ ì‚¬ìš©í•˜ë©´ ê°„ë‹¨íˆ ìºì‹œ í¬ê¸° ì œí•œê³¼ LRU ì •ì±…ì„ êµ¬í˜„ê°€ëŠ¥
- **íš¨ìœ¨ì **: í‰ê· ì ìœ¼ë¡œ O(1) ì‹œê°„ ë³µì¡ë„ë¡œ ë°ì´í„°ë¥¼ ê²€ìƒ‰í•˜ê³ , ì¶”ê°€/ì‚­ì œí•  ìˆ˜ ìˆë‹¤.
- **ìœ ì—°ì„±**: ì‚½ì… ìˆœì„œì™€ ì ‘ê·¼ ìˆœì„œë¥¼ ììœ ë¡­ê²Œ ì„¤ì • ê°€ëŠ¥

### `LinkedHashSet`ê³¼ `LinkedHashMap` ë¹„êµ

| íŠ¹ì„± | `LinkedHashSet` | `LinkedHashMap` |
| --- | --- | --- |
| ìˆœì„œ ìœ ì§€ | ì‚½ì… ìˆœì„œ ìœ ì§€ | ì‚½ì… ìˆœì„œ ë˜ëŠ” ì ‘ê·¼ ìˆœì„œ ìœ ì§€ (`accessOrder`) |
| LRU êµ¬í˜„ | ìˆ˜ë™ìœ¼ë¡œ ì ‘ê·¼ ìˆœì„œë¥¼ ê´€ë¦¬í•´ì•¼ ê°€ëŠ¥ | `removeEldestEntry`ë¡œ ê°„ë‹¨íˆ êµ¬í˜„ ê°€ëŠ¥ |
| í•­ëª© ì œê±° | ì˜¤ë˜ëœ í•­ëª©ì„ ì§ì ‘ ì°¾ì•„ ì œê±°í•´ì•¼ í•¨ (`Iterator`) | ìë™ìœ¼ë¡œ ì˜¤ë˜ëœ í•­ëª© ì œê±° ê°€ëŠ¥ |
| êµ¬í˜„ ë³µì¡ì„± | ë” ë†’ì€ ìˆ˜ì¤€ì˜ ë¡œì§ í•„ìš” | ë‚´ì¥ëœ ê¸°ëŠ¥ìœ¼ë¡œ ê°„ë‹¨íˆ ì²˜ë¦¬ ê°€ëŠ¥ |

Setì„ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ì´ìœ ë¥¼ ìœ„ì—ì„œ ì ê¹ ì¼ëŠ”ë° ì •í™•íˆ ë¹„êµí•˜ê³  ë„˜ì–´ê°€ë©´ ì¢‹ì„ ê²ƒ ê°™ì•„ì„œ ì •ë¦¬í•´ë³´ì•˜ë‹¤.

ìœ„ì˜ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ë‹¤ì‹œ í’€ì—ˆëŠ”ë° ë°”ë¡œ í•´ê²°!



## ì •ë‹µ

```java
import java.util.*;

class Solution {
    public int solution(int cacheSize, String[] cities) {
        if (cacheSize == 0) return cities.length * 5;

        int answer = 0;

        Map<String, String> map = new LinkedHashMap<>(cacheSize, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<String, String> old) {
                return size() > cacheSize; 
            }
        };

        for (String city : cities) {
            //ëŒ€ì†Œë¬¸ì
            city = city.toLowerCase();

            if (map.containsKey(city)) {
                answer += 1;
            } else {
                answer += 5; 
            }
             map.put(city, city); 
        }
        return answer;
    }
}

```