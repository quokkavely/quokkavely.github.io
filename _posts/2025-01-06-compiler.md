---
layout : single
title : "컴파일러와 인터프리터 (+ JIT 컴파일러러)"
categories: OS
tag : [CS, 컴파일러, 인터프리터, JIT컴파일러]
author_profile: true
---

📌 개인적인 공간으로 공부를 기록하고 복습하기 위해 사용하는 블로그입니다. <br>
정확하지 않은 정보가 있을 수 있으니 참고바랍니다 :😸 <br>
[틀린 내용은 댓글로 남겨주시면 복받으실거에요]  
{: .notice--primary}

# 컴파일러와 인터프리터

컴파일러와 인터프리터는 **고수준 프로그래밍 언어**로 작성된 코드를 **컴퓨터가 이해할 수 있는 기계어로 변환**하는 프로그램입니다.

두 방식 모두 같은 목표를 가지고 있지만, **코드 변환 방식**과 **실행 과정**에서 차이가 있습니다.

## **컴파일러**

1. 특징
    - **전체 변환**: 소스 코드를 **한 번에** 읽어들여 기계어로 변환
    - **결과물**: 실행 가능한 기계어 코드(바이너리 파일)를 생성
    - **속도**: 컴파일 단계는 시간이 걸리지만, 변환된 기계어는 직접 실행되므로 실행 속도가 빠름
    - **수정**: 코드를 수정할 경우 **다시 컴파일**이 필요
    - **예시**: C, C++, Go, Rust 등
2. 장점
    - 실행 속도가 빠르며, 대규모 프로젝트에 적합
    - 최적화가 잘 이루어져 **성능이 높음**
3. 단점
    - 코드 실행 전 **컴파일 시간**이 소요됨
    - 디버깅이 비교적 어려울 수 있음
4. 활용
    - 성능이 중요한 애플리케이션
    - 대규모 프로젝트
    - 하드웨어와 가까운 저수준 프로그래밍

## **인터프리터**

1. 특징
    - **한 줄씩 변환**: 소스 코드를 **한 줄씩** 읽어가며 기계어로 변환 후 바로 실행
    - **결과물**: 기계어로 변환된 코드가 별도로 저장되지 않음
    - **속도**: 실행 전 준비 과정이 없으므로 **즉시 실행 가능**하지만, 실행 속도는 느림
    - **수정**: 코드를 수정해도 **즉시 실행** 가능
    - **예시**: Python, JavaScript, PHP 등
2. 장점
    - 실행하기 쉽고, 코드 테스트와 디버깅에 적합
    - 동적 언어와 잘 맞아 생산성이 높음
3. 단점
    - 실행 속도가 느리고, 대규모 프로젝트에 부적합할 수 있음
    - 실행 시마다 변환 과정을 반복하므로 성능이 낮음
4. 활용
    - 빠른 프로토타이핑과 테스트가 필요한 경우
    - 배우기 쉽고 생산성이 중요한 경우

## **JIT(Just-In-Time) 컴파일러**

1. 특징
    - **혼합 방식**: 컴파일러와 인터프리터의 장점을 결합
    - **핫 스팟(hot spot)**: 자주 실행되는 코드를 실행 시점에 **동적으로 컴파일**
    - **최적화**: 실행 중 코드 분석 및 최적화를 수행
    - **캐싱**: 컴파일된 코드를 메모리에 저장하여 재사용
2. 장점
    - 자주 사용되는 코드의 실행 속도가 크게 향상
    - 인터프리터보다 빠르고 컴파일러보다 유연
3. 단점
    - **메모리 사용량** 증가
    - JIT 컴파일 과정에서의 오버헤드
4. 활용
    - 성능과 유연성이 모두 중요한 환경에서 적합
    - 현대적인 프로그래밍 언어(Java, JavaScript 등)에서 필수
5. 예시
    - **JVM(Java Virtual Machine)**: Java 코드 실행
    - **V8 엔진**: Node.js 및 Chrome 브라우저의 JavaScript 엔진
    - **.NET**: C#과 같은 언어를 실행하는 플랫폼

## **컴파일러 vs 인터프리터 vs JIT**

| **특징** | **컴파일러** | **인터프리터** | **JIT 컴파일러** |
| --- | --- | --- | --- |
| **변환 방식** | 전체 변환 | 한 줄 씩 변환 | 동적 변환 및 최적화 |
| **실행 속도** | 빠름 | 느림 | 빠름 |
| **코드 수정** | 다시 컴파일 필요 | 즉시 실행 가능 | 일부 수정 시 빠른 반영 가능 |
| **결과물** | 기계어 파일 생성 | 기계어 파일 없음 | 메모리 내 캐싱된 기계어 코드 |
| **예시 언어** | C, C++, Go | Python, JavaScript | Java, Node.js |

### **컴파일러와 인터프리터의 과정 비교**

1. **컴파일러**
    - **소스 코드 작성** → `코드 전체 변환(컴파일)` → 기계어 파일 생성 → 실행
        
        ```java
        +--------------+            +------------+            +------------+
        | Source Code  | --> 컴파일러 --> | Machine Code | --> 실행      |
        +--------------+            +------------+            +------------+
        ```
        
2. **인터프리터**
    - **소스 코드 작성** → `한 줄씩 읽고 변환 및 실행` → 즉시 실행
        
        ```
        +--------------+            +------------+            +------------+
        | Source Code  | --> 인터프리터 --> | 실행            |              |
        +--------------+            +------------+            +------------+
        ```
        
3. **JIT 컴파일러**
    - **소스 코드 작성** → `실행 시점에 핫스팟 컴파일 및 최적화` → 실행
        
        ```
        +--------------+     +--------------+     +------------+
        | Source Code  | --> | JIT Compiler | --> | Machine Code |
        +--------------+     +--------------+     +------------+
                                |
            +-------------------+
            |
            v
        (실행 중 최적화)
        
        ```
        

---


<br>
<br><br><br>