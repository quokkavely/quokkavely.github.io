---
layout : single
title : "[JAVA] 객체지향"
categories: JAVA-Learn
tag : [JAVA, 개념]
toc : true
toc_sticky : true
author_profile: true
---

📌 개인적인 공간으로 공부를 기록하고 복습하기 위해 사용하는 블로그입니다. <br>
정확하지 않은 정보가 있을 수 있으니 참고바랍니다 :😸 <br>
[틀린 내용은 댓글로 남겨주시면 복받으실거에요]  
{: .notice--primary}


# 자바는 객체지향언어
객체지향이 필요한 이유는 
객체를 추상화 해서 만드는 작업을 해야하는데<br/>
여기에 대한 반복작업을 계속 하면 중복작업이 생기므로<br/> 
이를 재활용하고 적은 노력으로 쉽게 코드를 변경하기 위함<br/>
즉, 생산성 향상으로 이어지게 됨 <br/>
어려운 말로 프로그래밍 설계의 측면에서 보면<br/>
1) **프로그램 개발 및 유지 보수에 드는 비용과 시간을 줄이기 위함.**<br/>
2) **객체를 통해 데이터를 관리하여 데이터를 손실없이 관리하기 용이**<br/>

코드의 재사용성/코드관리용이=유지보수/신뢰성 높은 프로그래밍 가능


## 클래스와 객체

1. 클래스 - 객체를 생성하기 위한 설계도라고 생각하기
    1. 클래스 정의  : 객체를 정의해 놓은 것
    2. 클래스의 용도 : 객체를 생성하는데 사용
2. 객체 - 클래스(TV설계도)에 의해 만들어진 제품(TV)
    1. 객체의 정의 : 실제로 존재하는 것 , 사물 또는 개념
    2. 객체의 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름
    3. 유형의 객체 : 책상,의자, 자동차, TV와 같은 사물
    4. 무형의 객체 : 수학공식, 프로그램 에러와 같은 논리나 개념

### 프로그래밍 관점에서 클래스는 두가지 정의를 내릴 수 있음.

1. **클래스 - 데이터와 함수의 결합**
    - **변수>배열>구조체>클래스 형태**로 발전
    - **변수** = 하나의 데이터를 저장할 수 있는 공간.
    - **배열** = 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
    - **구조체** = 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간.
    - **클래스** = 데이터와 함수의 결합. (구조체+함수)
2. **클래스 - 사용자 정의 타입.**
    
    프로그래밍 언어에서 제공하는 자료형 외에 프로그래머가 서로 관련된 변수를 묶어서 하나의 타입으로 새로 추가하는 것을 사용자 정의 타입이라고 함.
    

### 객체와 인스턴스

1. 클래스의 인스턴스화 : 클래스로부터 객체를 만드는 과정
2. 인스턴스: 어떤 클래스로부터 만들어진 객체

### 객체의 구성요소

객체는 속성과 기능, 두 종류의 구성요소로 이루어짐 = 객체는 속성과 기능의 집합.

클래스로부터 객체를 생성하면, 클래스에 정의된 속성과 기능을 가진 객체가 만들어 지는 것.

- 속성(Property) : 멤버변수, 특성,필드,상태
- 기능(function) : 메서드, 함수, 행위

### 인스턴스의 생성과 사용

```java
클래스명 변수명; //인스턴스를 참조하기 한 참조변수 선언
Tv t;

참조_변수명 = new  생성자() //인스턴스 생성 후 객체 주소를 참조변수에 저장
t = new Tv();

하나로 줄여서 아래와 같이 사용 가능

Tv t = new Tv(); 
```
객체 생성시 항상  new 가 들어감 <br/>
- 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야함.

### 변수

변수의 선언 위치가 변수의 종류와 범위를 결정.

<img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/84f1ee3d-508c-46c6-8454-4f0214fad645" width=300>

1. 클래스 변수
    1. 같은 클래스의 모든 인스턴스들이 공유하는 변수
    2. 인스턴스 생성 없이 ‘**클래스이름.클래스변수명**’ 으로 접근
    3. 클래스가 로딩될 때 생성되고 프로그램이 종료될 때 소멸
    4. static 변수는 필요한 경우에만 제한적으로 사용 =static 변수는 프로그램의 생명주기 동안 메모리에 상주하므로, 불필요한 메모리 사용을 초래할 수 있기 때문
2. 인스턴스 변수
    1. 각 인스턴스의 개별적인 저장공간.  인스턴스마다 다른 값 저장 가능
    2. 인스턴스 생성후, ‘**참조변수.인스턴스변수명**’으로 접근
    3. 인스턴스를 생성할 때 생성되고 참조변수가 없을 때는 가비지컬렉터에 의해 자동 제거됨.
3. 지역변수
    1. 메소드 내에 선언됨. 메서드 종료와 함께 소멸
    2. 조건문, 반복문의 블럭{} 내에 선언된 지역변수는 블럭을 벗어나면 소멸
4. 인스턴스변수는 인스턴스가 생성될 때마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스변수는 모든 인스턴스가 하나의 저장공간을 공유하므로 항상 공통된 값을 갖는다.
    1. 카드의 무늬나 숫자는 인스턴스변수
    2. 같은 카드의 폭과 높이는 모두 동일 - 클래스 변수

## 메서드

1. 정의 : 특정작업을 수행하는 일련의 문장을 하나로 묶은 것.
2. 사용이유 
    
    (1) 높은 재사용성 -여러 번 호출 가능, 다른 프로그램에서도 사용 가능
    
    (2) 중복 코드 제거 - 반복되는 문장을 묶어서 하나의 메서드로 만들면 대체 가능
    
    (3) 프로그램의 구조화 
    
3. 메서드의 선언과 구현
    
    (1) 메서드는 선언부 / 구현부로 나뉘어져 있다.
    
    (2) 선언부
    
    1. 메서드의 이름과 매개변수의 선언 그리고 반환 타입으로 구성
    2. ex) int add(int x,inty){ }
    3. 메서드의 이름 : 변수의 명명 규칙대로 작성
    4. 반환 타입을 적어야 하고 반환 값이 없는 경우 void 작성
    5. 메서드 내에 선언된 변수들은 지역변수라 함.
    
    (3)  구현부
    
    1. 메서드의 선언부 다음에 오는 중괄호 부분을 구현부라 함. 
    2. 메서드가 정상 종료되는 경우 메서드의 블럭의 끝에 도달했을 때/메서드 블럭을 수행중  return문을 만났을때
    3. return 문 : 현재 실행중인 메서드를 종료하고 호출한 메서드로 돌아간다.
    4. 반환 값이 없을 경우 return문만 쓰고(return;) 반환값이 있을 경우 return 뒤에 반환값을 지정해 주어야 한다.(return 반환값;)
    5. 반환타입이 void가 아닌 경우 구현부 안에 return 반환값 이 반드시 포함되어야함.
    6. return문은 하나의 값만 반환 할 수 있고 메서드의 반환 타입과  타입이 일치해야 함.
4. 메서드의 호출
    
    (1) 메서드를 호출하면 구현부{}의 문장들이 수행됨.
    
    1. 참조변수.메서드이름(값1,값2,…); //메서드 호출 방법.
    2. 참조변수.메서드이름(); //메서드에 선언된 매개변수가 없는 경우
    
    <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/12377664-85be-48a6-b587-3b00c53a1a5d" width =400/>
    [사진 출처 - 자바의 정석]
    
    (2) 인자와 매개변수
    
    1. 인자 : 메서드 호출시 ( ) 괄호 안에 지정해준 값
    2. 인자의 개수와 순서는 호출된 메서드에  선언된 매개변수와 일치해야 함.
    
    (3) 메서드의 실행흐름
    
5. Return문
    
    1) 현재 실행 중인 메서드를 종료하고 호출된 메서드로 돌아갈 때.
    
    2) 반환값의 유무에 관계없이 모든 메서드에는 적어도 하나의 return문이 있어야함.
    
    3) return 문을 적지 않아도 컴파일러가 마지막에 자동으로 추가함.
    
    4) return문의 개수는 최소화 하는 것이 좋다.
    

### JVM 메모리구조

<img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/0e482a33-b6f3-4459-aacb-c52077e567e3" width=400/>

1. 메서드 영역 : 클래스 정보와 클래스변수가 저장되는 곳
2. 호출스택 : 메서드의 작업공간, 메서드가 호출되면 메서드 수행에 필요한 메모리 공간을 할당받고 메서드가 종료되면 사용하던 메모리를 반환한다.
    - 호출스택의 특징
        <img src=""/>
    1) 메서드가 호출되면 수행에 필요한 메모리를 스택에 할당 받는다.
    2) 메서드가 수행을 마치면 사용했던 메모리를 반환
    3) 호출스택의 제일 위에 있는 메서드가 현재 실행중인 메서드
    4) 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드
3. 힙 : 인스턴스가 생성되는 공간, new 연산자에 의해서 생성되는 배열과 객체는

여기서 생성됨.

1. 메서드의 시작과 종료의 순서를 확인하는 예제
    
    ```java
    class CallStackTest{
    public static void main (String[]args){
     System.out.println("main(String[]args)이 시작되었음.");
     firstMethod();
     System.out.println("main(String[]args)이 끝났음.");
     }
     
     static void firstMethod(){
     System.out.println("firstMethod()이 시작되었음.");
     secondMethod();
     System.out.println("firstMethod()이 끝났음.");
     }
     
     static void secondMethod(){
     System.out.println("secondMethod()이 시작되었음.");
     System.out.println("secondMethod()이 끝났음.");
     
     --------------------------
     결과
     "main(String[]args)이 시작되었음."
     "firstMethod()이 시작되었음."
     "secondMethod()이 시작되었음."
     "secondMethod()이 끝났음."
     "firstMethod()이 끝났음."
     "main(String[]args)이 끝났음."
    
    ```
    

**기본형 매개변수와 참조형 매개변수**

기본형 매개변수 - 변수값을 읽기만 할 수 있음 (read only)

<img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/90e0f658-d93b-4834-8644-979c1efea1d5" width=400>

<img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/5eac88d7-1756-45a5-8b42-11b745d46897" width=200>


참조형 매개변수 - 변수의 값을 읽고 변경 가능 (read & write)

<img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/7edb4aa6-93a2-430e-a40d-e94ecb7d1de5" width=400/>

<img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/b43e6764-61a4-44aa-bd9e-b993689e3b03" width=200>

### 재귀호출

1. 재귀호출은 메서드에서 자기자신을 반복적으로 호출하는 것.
2. 재귀호출은 반복문으로 바꿀수있고 반복문 보다 성능이 나쁨
3. 이해하기 쉽고 간결한 코드로 작성가능
4. 예시) 팩토리얼/제곱/트리운행/ 폴더목록표시

### 클래스 매서드와 인스턴스 메서드

**인스턴스 메서드**

1. 인스턴스 생성 후 ‘참조변수.메서드이름()’으로 호출
2. 인스턴스 변수나 인스턴스 메서드와 관련된 작업을 하는 메서드
3. 메서드 내에서 인스턴스 변수 사용 가능 

**클래스 메서드 (static method)**

1. 객체 생성없이 ‘클래스이름.메서드이름()’으로 호출
2.  인스턴스 변수나 인스턴스 메서드와 관련없는 작업을 하는 메서드
3.  메서드 내에서 인스턴스변수 사용 불가
4. 메서드 내에서 인스턴스변수를 사용하지 않는다면 static을 붙이는 것을 고려

 

클래스 멤버와 인스턴스 멤버간의 참조와 호출

1) 같은 클래스의 멤버간에는 객체생성이나 참조변수 없이 참조할 수 있지만

2) static멤버들은 인스턴스 멤버들을 참조할 수 없음.

### 오버로딩

1. 하나의 클래스에 같은 이름의 메서드를 여러개 정의하는 것을 메서드 오버로딩이라 함.
2. 오버로딩의 조건
    
    (1) 메서드의 이름이 같아야 함
    
    (2) 매개변수의 개수 또는 타입이 달라야 함.
    
    (3) 매개변수는 같고 리턴(반환)타입이 다른 경우는 오버로딩이 성립되지 않음. - 리턴타입은 오버로딩을 구현하는데 아무런 영향을 주지 않음.
    
3. 예시 
    
    (1) System.out.println 메서드
    
    다양하게 오버로딩된 메서드를 제공함으로써 모든 변수를 출력할 수 있도록 설계
    ```java
        void println()
        void println(boolean x)
        void println(char x)
        void println(char[] x)
        void println(double x)
        void println(float x)
        void println(int x)
        void println(long x)
        void println(Object x)
        void println(String x)
    ```
    
    (2) 매개변수의 이름이 다른 것은 오버로딩이 아님,
    
    - int add(int a, int b) {return a+b};
    - int add(int x, int y) {return x+y};
    
    (3) 리턴타입은 오버로딩 성립조건이 안됨,
    
    - int add(int a, int b){return a+b}
    - long add(int a, int b){retrun (long)(a+b);}
    
    (4) 매개변수의 타입이 다른 것은 성립.
    
    - long add (int a, long b) (return a+b;}
    - long add(int a, int b){retrun a+b;}
    
    (5) 오버로딩의 올바른 예
    
    ```java
    //같은 의미의 작업이 아래  3행에서 진행되고 있음. - 오버로딩
    int add (int a, int b){ return a+b ;}
    long add (long a,long b) {return a+b;}
    int add(int[]a){
    	int result=0;
    	for(int i =0; i< a.length; i++}{
    		result+=a[i];
    		}
    		return result;
    }
    ```
<br/>

<br/>
<br/>

### Comment
드디어 객체지향
아직은 크게 와닿지는 않고
그냥 그런가보다 하는 정도이다..<br/>
내가 이해한 건 코드를 유지보수 하고 재사용성을 높이려고
다른 클래스를 가져와서 사용하는 것. <br/>그것을 객체라고 부르는 것...?인 것 같다 <br/>
아직 객체지향의 시작이지만
도대체 얼마나 어려울까 기대가 된다..!


---
참고자료 - 자바의 정석
<br/>
<br/>
<br/>
<br/>
<br/>