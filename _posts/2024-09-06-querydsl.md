---
layout : single
title : "[Project] QueryDSL 사용하기 (설정 방법 및 장점)"
categories: Project
tag : [project2, practice]
author_profile: true
---

📌 개인적인 공간으로 공부를 기록하고 복습하기 위해 사용하는 블로그입니다. <br>
정확하지 않은 정보가 있을 수 있으니 참고바랍니다 :😸 <br>
[틀린 내용은 댓글로 남겨주시면 복받으실거에요]  
{: .notice--primary}

---

## QueryDSL

Order에서 get 요청시 검색기능을 날짜와 함께 itemCd, 또는 buyerCd 그리고 주문 번호 등 사용자가 다양한 조건으로 검색을 사용할 수 있도록 해야하는데 엘라스틱서치는 다른 분이 고생하는 걸 보기도 했고 기획 때 후순위로 미뤄놓아서 메서드를 여러 개 구현해야 하나 생각하다가

날짜 검색은 어떻게 해야할지 구글링 했더니 queryDSL이라는 것을 발견했고 , 동적 쿼리라 null이 들어오면 조건을 걸지 않는 좋은 기능인 것 같아서 바로 적용해보았다.

### Build.gradle설정

사실 여기부터 헤맸는데,

build.gradle 설정도 springboot 버전에 따라 다르게 적용해야 해서 몇 시간을 싸우다가 버전 별로 잘 정리해두신 분이 있어서 참고했다.

[[Spring] QueryDsl gradle 설정 방법과 QueryDsl QClass 파일 생성 위치 (velog.io)](https://velog.io/@min-zi/Spring-QueryDsl-gradle-%EC%84%A4%EC%A0%95-Spring-boot-3.0-%EC%9D%B4%EC%83%81)

아래는 SpringBoot 2.7.0 버전일 때 사용한 설정 파일이다.

```java
plugins {
    id 'org.springframework.boot' version '2.7.0'
    id 'io.spring.dependency-management' version '1.0.11.RELEASE'
    id 'java'
}

def querydslDir = "$buildDir/generated/querydsl"
sourceSets {
    main {
        java {
            srcDirs = ['src/main/java', querydslDir]  // QueryDSL로 생성된 경로 추가
        }
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    implementation "com.querydsl:querydsl-jpa"
    annotationProcessor "com.querydsl:querydsl-apt:${dependencyManagement.importedProperties['querydsl.version']}:jpa"
}

```

뭐 하나 해결하면 이제는 Q파일이 없다고 에러가 무진장 발생해서 경로를 추가했다.
위 설정에서 중요한 부분은 `querydslDir` 경로를 추가해서 QueryDSL로 생성된 Q 클래스를 찾을 수 있게 해주는 것이다. 

그런 다음, `clean` → `build` 과정을 거치면 Q[Entity이름] 형태로 자동으로 생성된다. 

예를 들어, `Order`라는 엔티티가 있으면 `QOrder` 클래스가 생성되는 식이다. 이걸 가지고 쿼리를 타입 안전하게 짤 수 있다.

### CustomRepository, RepositoryImpl 생성

1. CustomRepository :  interface 생성
    
    ```java
    public interface OrderQueryRepositoryCustom {
        Page<OrderHeaders> findByCreatedAtBetweenAndOrderStatusAndBuyer_BuyerCdAndOrderItems_ItemCdAndOrderCd
        (OrderDto.OrderSearchRequest orderSearchRequest, Pageable pageable);
    }
    ```
    
    여기서는 특정 기간 내에 주문 상태, 구매자 코드, 주문 항목 코드, 그리고 주문 코드를 기반으로 `OrderHeaders`를 검색하는 쿼리를 작성할 예정이다. `Pageable`을 사용해서 페이징 처리까지 할 수 있게 구성했다.
    
2. RepositoryImpl
위에서 정의한 인터페이스의 구현체를 만들어야 한다. 이때 중요한 점은 `JPAQueryFactory`를 의존성 주입받아 사용한다는 것이다.
    
    `JPAQueryFactory`는 QueryDSL로 동적 쿼리를 만들 때 매우 유용하게 사용된다.
    
    - 의존성 주입
        
        ```java
        @Repository
        public class OrderQueryRepositoryImpl implements OrderQueryRepositoryCustom {
        
            private final JPAQueryFactory queryFactory;
        
            public OrderQueryRepositoryImpl(JPAQueryFactory queryFactory) {
                this.queryFactory = queryFactory;
            }
        ```
        
    
    - 구현 메서드
        
        ```java
           @Override
            public Page<OrderHeaders> findByCreatedAtBetweenAndOrderStatusAndBuyer_BuyerCdAndOrderItems_ItemCdAndOrderCd
            (OrderDto.OrderSearchRequest orderSearchRequest, Pageable pageable) {
        
                QOrderHeaders orderHeaders = QOrderHeaders.orderHeaders;
                QBuyer buyer = QBuyer.buyer;
                QOrderItems orderItems = QOrderItems.orderItems;
        				
        				//BooleanBuilder를 활용해 다양한 조건을 조합할 수 있다.
                BooleanBuilder builder = new BooleanBuilder();
                
                //필터를 적용해서 null이라면 조건을 걸지 않고, 
                //null 이 아니면 조건을 걸어 데이터를 조회할 수 있도록 동적으로 구현할 수 있다
        
                // 날짜 필터
                if (orderSearchRequest.getSearchStartDate() != null && orderSearchRequest.getSearchEndDate() != null) {
                    LocalDateTime searchStartDate = orderSearchRequest.getSearchStartDate().atStartOfDay();
                    LocalDateTime searchEndDate = orderSearchRequest.getSearchEndDate().atTime(23, 59, 59);
                    builder.and(orderHeaders.requestDate.between(searchStartDate, searchEndDate));
                }
        
                // 상태 필터
                if (orderSearchRequest.getStatus() != null) {
                    builder.and(orderHeaders.orderStatus.eq(orderSearchRequest.getStatus()));
                }
        
                // BuyerCode 필터
                if (orderSearchRequest.getBuyerCd() != null && !orderSearchRequest.getBuyerCd().trim().isEmpty()) {
                    builder.and(buyer.buyerCd.eq(orderSearchRequest.getBuyerCd()));
                }
        
                // ItemCode 필터
                if (orderSearchRequest.getItemCd() != null && !orderSearchRequest.getItemCd().trim().isEmpty()) {
                    builder.and(orderItems.itemCd.eq(orderSearchRequest.getItemCd()));
                }
        
                //orderCode 필터
                if (orderSearchRequest.getOrderCd() != null) {
                    builder.and(orderHeaders.orderCd.eq(orderSearchRequest.getOrderCd()));
                }
        
                List<OrderHeaders> results = queryFactory
                        .selectDistinct(orderHeaders)
                        .from(orderHeaders)
                        .leftJoin(orderHeaders.buyer, buyer)
                        .leftJoin(orderHeaders.orderItems, orderItems).fetchJoin() 
                        .where(builder)
                        .offset(pageable.getOffset())
                        .limit(pageable.getPageSize())
                        .orderBy(orderHeaders.createdAt.desc())
                        .fetch();
        
                long total = queryFactory
                        .select(orderHeaders.countDistinct())
                        .from(orderHeaders)
                        .leftJoin(orderHeaders.buyer, buyer)
                        .leftJoin(orderHeaders.orderItems, orderItems)
                        .where(builder)
                        .fetchOne();
        
                return new PageImpl<>(results, pageable, total);
            }
        }
        ```
        
        우여곡절 끝에 작성하긴 했는데 동적으로 잘 실행된다.
        

### JPQL VS QueryDSL

이렇게 하다 보니 기존에 사용하던 JPQL과 어떤 차이점이 있는지 정확하게 알고 싶어서 공부 후 정리해보았다.

런타임 에러보다는 컴파일 에러가 좋은데, 매번  JPQL에서 런타임 에러 발생해서  조마조마 했는데 QueryDSL 사용할 때는 그럴 일이 없어서 좋았다,.

1. **JPQL (Java Persistence Query Language)**

- **사용 방식**:
    
    JPQL은 SQL과 비슷한 구문을 사용해서 엔티티 객체를 대상으로 쿼리를 작성하는 방식이다. 쿼리를 문자열로 직접 작성하고, `@Query` 같은 어노테이션을 통해 실행한다.
    
    그런데 이 방식은 문자열로 쿼리를 작성하는 만큼, 컴파일 타임에 쿼리 오류를 잡을 수 없다는 단점이 있다.
    
- **특징**:
    - SQL과 유사한 문법으로 쿼리를 작성하니 익숙한 느낌이다.
    - 하지만 쿼리를 문자열로 작성하다 보니, 런타임에야 오류를 발견할 수 있다.
    - 문자열 기반이라 가독성도 떨어지고, 유지보수도 힘들다.
    - 특히 **동적 쿼리 작성**이 어렵다. 동적 쿼리를 만들려면 `if`문을 통해 조건을 일일이 관리해야 하는데, 그게 또 번거롭다.
- **예시**:
    
    ```java
    @Query("SELECT o FROM Order o WHERE o.status = :status")
    List<Order> findOrdersByStatus(@Param("status") String status);
    ```
    
    위 코드는 `status`에 따라 `Order` 데이터를 조회하는 간단한 JPQL 쿼리다. 문자열로 쿼리를 직접 작성했기 때문에 동적 쿼리를 만들거나 조건을 추가할 때는 조금 귀찮을 수 있다.
    

2. **QueryDSL**

- **사용 방식**:
    
    QueryDSL은 쿼리를 **타입 안전**하게 작성할 수 있다. 쿼리를 문자열이 아니라 **자바 코드**로 작성하는데, 엔티티의 필드나 조건을 직접 메서드 형태로 사용하니까 쿼리 오류를 컴파일 타임에 바로 확인할 수 있다.
    
    이런 덕분에 복잡한 쿼리나 동적 쿼리 작성할 때 진짜 편리하다.
    
- **특징**:
    - **타입 안전성**: 컴파일 타임에 쿼리 오류를 바로 잡아준다.
    - **가독성**: 쿼리를 자바 코드로 작성하니까 유지보수하기도 훨씬 수월하다.
    - **동적 쿼리**: 복잡한 조건을 유연하게 처리할 수 있어서 동적 쿼리 작성이 훨씬 쉽다.
    - 복잡한 쿼리도 깔끔하게 처리할 수 있다. 특히 조건에 따라 쿼리를 동적으로 생성해야 하는 상황에서 빛을 발한다.
- **예시**:
    
    ```java
    QOrder order = QOrder.order;
    List<Order> orders = queryFactory.selectFrom(order)
        .where(order.status.eq(OrderStatus.REQUEST_TEMP))
        .fetch();
    ```
    
    자바 코드로 쿼리를 작성하니 조건을 추가하거나 수정할 때도 훨씬 직관적이다. 특히 복잡한 쿼리일수록 QueryDSL을 쓰면 훨씬 깔끔해진다.
    
1. 정리
    
    
    | **특징** | **JPQL** | **QueryDSL** |
    | --- | --- | --- |
    | **쿼리 방식** | 문자열 기반 쿼리 (`@Query`) | 자바 코드 기반 (메서드 체인 형태) |
    | **타입 안전성** | 없음 (런타임 시 오류 발생 가능) | 있음 (컴파일 시점에 오류 감지 가능) |
    | **동적 쿼리** | 복잡한 동적 쿼리 작성이 어려움 | 동적 쿼리 작성에 매우 유리 |
    | **가독성** | 복잡한 쿼리는 가독성이 떨어짐 | 가독성이 좋고 코드로 작성해서 직관적임 |
    | **쿼리 오류 감지** | 컴파일 시점에 오류 감지 불가 | 컴파일 시점에 오류 감지 가능 |
    | **사용 복잡도** | 간단한 쿼리 작성에 적합 | 동적/복잡한 쿼리 작성에 적합 |

결론적으로, **작업이 간단하고 쿼리의 복잡도가 낮다면 JPQL**을 써도 좋지만, **복잡한 쿼리와 동적 조건이 많다면 QueryDSL**을 사용하는 게 훨씬 낫다. 나는 요즘 QueryDSL에 더 손이 많이 가는 것 같다. 역시 코드가 깔끔하면 기분도 좋으니까! 😄

간단하게 구현과 JPQL에 대해서 공부했는데 다음에는 만난 trouble에 대해서 리뷰 해야겠다.

### QueryDSL의 장점

1. **타입 안전성**:
    - QueryDSL은 컴파일 시점에 오류를 잡아낼 수 있어서, SQL처럼 문자열로 쿼리를 작성할 때 발생할 수 있는 실수를 미리 방지할 수 있다.
    - SQL이나 JPQL에서 오타가 나거나 컬럼명을 잘못 적어도 런타임에야 알 수 있는 경우가 많은데, QueryDSL은 그걸 미리 잡아준다. 이게 진짜 큰 장점이다.
2. **가독성 향상**:
    - 메서드 체이닝 방식으로 쿼리를 작성하다 보니 SQL을 직접 쓰는 것보다 훨씬 코드가 직관적이다.
    - 특히, 복잡한 쿼리도 메서드 체이닝으로 연결하면서 깔끔하게 정리할 수 있어서, 읽기도 좋고 나중에 유지보수하기에도 훨씬 수월하다.
3. **동적 쿼리 작성이 용이**:
    - 동적 쿼리를 작성할 때는 특히 빛을 발하는데, `BooleanBuilder` 같은 도구를 이용해서 조건을 자유롭게 추가하거나 제거할 수 있다.
    - 덕분에 복잡한 조건문도 깔끔하게 처리할 수 있다. 예를 들어 검색 조건이 여러 개일 때 그 조건을 유연하게 적용할 수 있어서 매우 편리했다.
4. **재사용성**:
    - QueryDSL로 작성한 쿼리는 재사용하기가 매우 쉬워서, 자주 사용하는 조건들을 따로 메서드로 빼두면 여러 곳에서 재활용할 수 있다.
    - 쿼리 로직을 모듈화해서 코드 중복을 줄이는 데 유용한데, 이 부분에서 코드 유지보수가 훨씬 쉬워진다.
5. **다양한 데이터베이스 지원**:
    - QueryDSL은 단순히 JPA에서만 쓸 수 있는 게 아니라, SQL, MongoDB, Lucene 등 다양한 데이터베이스와도 호환된다.
    - 프로젝트에 맞춰 다양한 데이터 소스와 쉽게 연동할 수 있어서 이점이 크다.
    - 그래서 다중 데이터베이스 환경에서도 동일한 문법으로 작업할 수 있는 것이 큰 장점이다.
6. **데이터베이스 독립적**:
    - JPA와의 통합 덕분에, QueryDSL로 작성한 쿼리는 데이터베이스에 종속되지 않는다.
    - 어떤 데이터베이스를 쓰든 동일한 쿼리 문법을 사용할 수 있어서, DB 벤더 변경이 있을 때도 코드를 크게 수정할 필요가 없다.

내가 생각하기에 가장 큰 장점은 바로 타입 안정성 인 것 같다 조회해야 할 것들이 많아지면서 JPQL 사용하다가 맨날 에러나서 실행하다가 중단되고 빨간 글씨 잔뜩 보는데 QueryDSL사용하면서는 거의 만나본적 없는듯!