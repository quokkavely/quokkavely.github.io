---
layout : single
title : "[Security] Security-basic"
categories: Spring
tag : [Spring, Practice, Security]
author_profile: true
---


## Spring Security 란?

애플리케이션에 Security를 적용하지 않으면

1. 로그인 기능 (인증,Authentication)이 없음.
2. API 에 대한 권한 부여(인가, Athorization)기능이 없음.

    인증과 인가 중에 뭐가 먼저 진행? → 인증이 먼저 ➡️ 그다음 **인가**처리를 하고 보냄

3. 웹 보안 취약점에 대한 대비가 전혀 이루어지지 않았음,<br/> 즉, 웹 애플리케이션을 위협하는 세션 고정 공격, 클릭재킹 공격, CSRF 등의 보안 취약점에 대한<br/> 고려가 전혀 이루어지지 않은 상태이다.

### ✏️ Spring Security

Spring MVC 기반 애플리케이션의 인증(Authentication)과 인가(Authorization or 권한 부여) 기능을 지원하는 보안 프레임워크로써,</br>  Spring MVC 기반 애플리케이션에 보안을 적용하기 위한 사실상의 표준

Spring에서 지원하는 Interceptor나 Servlet Filter를 이용해서 보안 기능을 직접 구현할 수 있지만<br/> 웹 애플리케이션 보안을 대부분의 기능을 Spring Security에서 안정적으로 지원하고 있으므로<br/> 구조적으로 잘 만들어진 검증된 Spring Security를 이용하는 것이 안전한 선택

### ✏️ Interceptor와 Filter

<img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/c19d59ad-f450-46e6-80af-a11fae9e1b0d" width=400/>

- interceptor는 컨트롤러 메서드로 넘어가기 직전에 가로채서 처리하고 보내줌. (보완관련 이슈처리, 인증-인가)
- 그런데 interceptor 사용 안하고 filter를 사용할 것.<br/>(왜냐면 보안은 초기 단계에서 요청되야 하는데 filter 가 더 일찍 요청을 가로채어서 처리 할 수 있기 때문이다.-전역에서 적용가능)
- filter는 브라우저에서 디스패쳐 서블릿으로 넘어가기 직전에 처리한다.
- 보안 관련 작업을 위해 Spring Security에서는 주로 Filter기반으로 사용한다.
- Spring Security의 필터가 과거에는 DispatcherServlet 전에 동작하면서 Spring 컨테이너의 빈들을 직접 활용하기 어려웠지만, 현재는 이러한 제약이 해결되어 필터도 Spring의 빈을 주입받아 사용할 수 있게 되었다.
- 6버전 부터는 람다식을 사용 , 아직 6버전을 사용하는 곳이 많지 않아서 5.8버전으로 공부할 예정.

### ✏️ Spring Security로 할 수 있는 보안 강화 기능

Spring Security를 애플리케이션에 적용하면 다음과 같은 일들을 할 수 있다.

- 다양한 유형(**폼 로그인 인증**, **토큰 기반 인증**, **OAuth 2 기반 인증**, LDAP 인증)의 사용자 인증 기능 적용
- **애플리케이션 사용자의 역할(Role)에 따른 권한 레벨 적용**
- **애플리케이션에서 제공하는 리소스에 대한 접근 제어**
- **민감한 정보에 대한 데이터 암호화**
- SSL 적용
- 일반적으로 알려진 웹 보안 공격 차단

이 외에도 SSO, 클라이언트 인증서 기반 인증, 메서드 보안, 접근 제어 목록(Access Control List) 같은 보안을 위한 기능들을 지원한다.

### ✏️ Spring Security에서 사용하는 용어 정리

- **Principal(주체) → 누가(who?)라고 생각하면 됨.**
    - Spring Security에서 사용되는 `Principal`은 애플리케이션에서 작업을 수행할 수 있는 사용자, 디바이스 또는 시스템 등이 될 수 있으며, <br/> 일반적으로 인증 프로세스가 성공적으로 수행된 사용자의 계정 정보를 의미한다.
    - 신원 증명이랑은 별개 ⇒ 이건 credential이라고 함 .
- **Authentication(인증)**
    - 애플리케이션을 사용하는 사용자가 본인이 맞음을 증명하는 절차를 의미
    - 정상적으로 수행하기 위해서는 사용자를 식별하기 위한 정보가 필요한데 이를 `Credential`(신원 증명 정보)이라고 한다.
    - `Credential` 은 일상에서 대표적인 예로 주민등록증, 그리고 특정 사이트에서 로그인을 위해 입력하는 **패스워드**도 로그인 아이디를 증명하기위한 **Credential**이다.
- **Authorization(인가 또는 권한 부여)**
    - Authentication이 정상적으로 수행된 사용자에게 하나 이상의 권한(authority)을 부여하여<br/> 특정 애플리케이션의 특정 리소스에 접근할 수 있게 허가하는 과정을 의미한다.
    - 반드시 Authentication 과정 이후 수행되어야 하며 권한은 일반적으로 역할(Role) 형태로 부여된다.
- **Access Control(접근 제어)**
    - 사용자가 애플리케이션의 리소스에 접근하는 행위를 제어하는 것을 의미


### ✏️ Spring Security를 사용해야 하는 이유

- 가장 큰 이유는 **보안을 강화하기 위한 솔루션으로 Spring Security 만 한 다른 프레임워크가 존재하지 않기 때문** <br/> Spring Security가 두 세가지 보안 프레임워크를 붙인 것보다 더 나은 경우가 대다수.
- Spring Security는 특정 보안 요구 사항을 만족하기 위한 커스터마이징이 용이하고, 유연한 확장이 가능하다. → 커스터마이징이 어려운 경우가 많음.

<br/>


# Spring Security의 인증처리 흐름

SSR로 구현, 서서히 개선해 나갈 예정

### ✏️ SSR과 CSR

1. **SSR**(Server Side Rendering) 방식의 애플리케이션은 세션 기반의 폼 로그인 방식을 적용하기에<br/> 가장 적합한 애플리케이션이며,<br/> 또한 폼 로그인 방식은 Spring Security에 처음 입문하는 사람들이 이해하기에 가장 적합한 인증 방식<Br/>
    ⭐ CSR(Client Side Rendering) 방식으로 이때동안 애플리케이션 구현 해왔지만,<br/> Spring Security를 입문하기 위해 SSR 방식 사용

### ✏️ Hello Spring Security 샘플 애플리케이션의 구조

HTML 뷰를 구성하기 위해 **타임리프(Thymeleaf)**라는 템플릿 엔진을 사용

<img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/b0e575ab-bd3b-4055-a0cc-5a34d2b5cf9c" width=200/>

1. <span style="color:Green">**Header**</span>
    
    ```html
    <html xmlns:th="<http://www.thymeleaf.org>"
          xmlns:sec="<http://www.thymeleaf.org/thymeleaf-extras-springsecurity5>"> <!-- (1) -->
    <body>
    <div align="right" th:fragment="header">
        <a href="/members/register" class="text-decoration-none">회원가입</a> |
        <span sec:authorize="isAuthenticated()"> <!-- (2) 인증이 되었으면 보여지는 것들. -->
                    <span sec:authorize="hasRole('USER')">  <!-- (3) -->
                        <a href="/members/my-page" class="text-decoration-none">마이페이지</a> |
                    </span>
                    <a href="/logout" class="text-decoration-none">로그아웃</a>  <!-- (4) -->
                    <span th:text="${#authentication.name}">홍길동</span>님  <!-- (5) -->
                </span>
    
        <span sec:authorize="!isAuthenticated()"> <!-- (6) 인증이 되지 않았으면 -->
                    <a href="/auths/login-form" class="text-decoration-none">로그인</a>
                </span>
    </div>
    </body>
    </html>
    ```
    
2. <span style="color:Green">**회원가입 HTML**</span>
    
    ```html
    <!DOCTYPE html>
    <html xmlns:th="<http://www.thymeleaf.org>"
          xmlns:layout="<http://www.ultraq.net.nz/thymeleaf/layout>"
          layout:decorate="layouts/common-layout">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Hello Spring Security Coffee Shop</title>
    </head>
    <body>
        <hr />
        <div class="container" layout:fragment="content">
            <!-- (1) 회원 가입 폼 -->
            <form action="/members/register" method="post">
                <div class="row">
                    <div class="col-xs-2">
                        <input type="text" name="fullName" class="form-control" placeholder="User Name"/>
                    </div>
                </div>
                <div class="row" style="margin-top: 20px">
                    <div class="col-xs-2">
                        <input type="email" name="email" class="form-control" placeholder="Email"/>
                    </div>
                </div>
                <div class="row" style="margin-top: 20px">
                    <div class="col-xs-2">
                        <input type="password" name="password" class="form-control" placeholder="Password"/>
                    </div>
                </div>
    
                <button class="btn btn-outline-secondary" style="margin-top: 20px">회원 가입</button>
            </form>
        </div>
    </body>
    </html>
    
    ```
    
3. <span style="color:Green">**로그인**</span>
    
   <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/dd878633-e459-42b8-bc9d-03b12e060c3f" width=400/>
    
    <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/d9803082-59a6-4e63-9198-c85f29d1517b" width=400/>
    
    로그인 화면 역시 HTML form 태그로 구성이 되어 있으며,<br/> HTML의 form 방식으로 로그인 인증을 진행하기 때문에<br/> Spring Security에서도 이러한 인증 방식을 **폼 로그인 인증**
    
4. <span style="color:Green">**서브사이드렌더링 방식이기 때문에 객체를 보내지 않는다.**</span>
    
    <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/ee46f772-0427-4550-8b13-1ef6b63dbe13" width=400/>  
    

### 문제점

- 로그인 기능이 구체적으로 구현되어 있지 않음. → 인증, 인가를 구현해야 함,
    
    ```java
    package com.springboot.auth;
    
    import org.springframework.stereotype.Controller;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestMapping;
    
    @Controller
    @RequestMapping("/auths")
    public class AuthController {
        @GetMapping("/login-form")
        public String loginForm() {
            return "login";
        }
    
        @GetMapping("/access-denied")
        public String accessDenied() {
            return "access-denied";
        }
    
        // (1)
        @PostMapping("/login")
        public String login() {
            System.out.println("Login successfully!");
            return "home";
        }
    }
    
    ```
    
    로그인 인증이 정상적으로 이루어지지 않기 때문에 **커피를 주문하는 회원이든, 매장에서 커피를 만들어서 제공하는 카페 관계자이든 상관없이 모든 화면에 자유롭게 접근할 수 있다.**
    

## 애플리케이션에 Spring Security 적용

1. gradle에 주석처리 되어있는 인증인가를 해제하여 의존주입한다.
    
    <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/6a55d53a-2307-4baf-8cc8-b3502772b51e" width=400/>
    

- 원래 HomeController에서 기본 url로 이동시 home으로 가게 설정되어있는데<br/>스프링 시큐리티를 적용하면 기본으로 제공해주는 기능은 첫 홈 화면이 로그인 화면으로 바뀐다.
    
   <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/173dae64-c4a1-41b4-a5a1-443f5c48e00b" width=400/>
    

- 로그인할 때 아이디는 기본으로 user이고 비밀번호는 프로그램 실행시 제공된다(매번 달라짐)
    
    <img src = "https://github.com/quokkavely/quokkavely.github.io/assets/165968530/81d2a392-13ac-4df1-ab9c-9e36c4d5441e"/>
    

- 내 마음대로 아이디와 비밀 번호를 적으면 실패까지 알려준다.
    
    <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/710c20e0-d20f-48d9-a5dd-2614834d58ca" width=300/>
    
- 실무에 적용하기 힘듬 → 접속할 때마다 비밀번호가 바뀌게 되고, 로그인 해서 들어가면 로그인 화면이 또 있다(내가 구현한 것)
- 스프링에서 기본으로 제공해주는 첫 화면의 로그인화면과 내가 구현한 로그인 화면 두 개가 중복해서 생기게 됨.

### 1️⃣ 비밀번호 설정 변경

 ⭐ **Spring Security Configuration 적용 →** 클래스에서 Spring Security에서 지원하는 인증과 권한 부여 설정하기

- 프로그램 설정시 생성되는 비밀번호가 아닌
- 매번 비밀번호가 바뀌는 것을 다시 설정할 예정, db는 인메모리 사용

<span style="color:Green">**SecurityConfiguration**</span> 

```java
package com.springboot.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.provisioning.UserDetailsManager;

@Configuration //Configuration과 빈이 있으면 반환하는 객체를 빈으로 등록하게 됨.
public class SecurityConfiguration {
    @Bean //스프링 컨테이너의 도움을 받기 위함
    public UserDetailsManager userDetailService(){
        UserDetails userDetails =
                User.withDefaultPasswordEncoder()
                        .username("jerry@gmail.com") //일반적으로 통용되는 아이디의 개념.
                        .password("wpfl")
                        .roles("USER") //인가 : 권한을 뭘 줄 것인지?
                        .build(); // 3가지를 담고 빌드하면
        return new InMemoryUserDetailsManager(userDetails);
        //유저객체가 나온다.
        // 메서드명을 보면 UserDetalis를 관리하는 역할을 하는 매니저로 반환해야 하는데
        // 인메모리 매니저로 반환함. 인터페이스로 구현되어있고 추상화 되어있기 때문
        // 데이터베이스를 실제로 사용하지 않고 있기 때문에 인메모리DB의 구현체로 사용
        // 빈은 userDetailService라는 메서드 명으로 등록하게 된다.

    }
}

```

1. **UserDetails** 인터페이스는 인증된 사용자의 핵심 정보를 포함하고 있으며,<br/> UserDetails 구현체인  User 클래스를 이용해서 사용자의 인증 정보를 생성한다.
    - UserDetails
        
        <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/41d1c986-ab2f-4986-b399-c7a28c23ce66" width=400/>
        
    - User
        
        <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/c965919e-6a7b-4f87-98c4-3f86372550e2" width=500/>
        
        - 여기서 username은 사람의 이름이 아닌 고유한 사용자를 식별할 수 있는 사용자 아이디 같은 값
        <br/>

        - <span style="color:Green">**User class에 있는 static Method → withDefaultPasswordEncorder( )** 
            <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/999ecb6f-6568-46ca-9452-fbec53b18a00" width=400/><br/>
            - **withDefaultPasswordEncorder( ) 로 인해 암호화 된다.**
            
            API 문서에서 해당 메서드에는 더이상 사용하지말라는 **@Deprecated** 이 달려있지만→ 실제 서비스환경에서는 사용하지 말라는 의미로 애너테이션이 달려있는 것 - 지금 연습단계라서 의미 둘 필요 없고 하나씩 개선예정
            <br/>
            
2. 반환은 UserDetailsManager로 해야하는데,  InMemoryUserDetailsManager로 반환함. 
    - 인터페이스로 구현되어있고 추상화 되어있기 때문
        
        <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/6ff70fe4-99a6-47f3-a2bc-7e9b7e104fa6" width=500/>
        

### 2️⃣ 커스텀 로그인 페이지 사용, 폼로그인 구현 (HTTP 보안 구성)

**SecurityConfiguration**에 filterChain 메서드를 생성 <br/> ⇒ HttpSecurity를 파라미터로 가지고, SecurityFilterChain을 리턴하는 형태의 메서드를 정의하면 HTTP 보안 설정을 구성할 수 있다

```java
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        //httpsecurity : 웹보안을 위해서 사용되는 클래스
        //로그인이 또 있으니까 내가 구현한 로그인페이지로 사용하도록 하게 변경하기 위해서 메서드만듬
        //폼로그인으로 구현되어 있기 때문에 폼로그인으로 사용예정
						
				//(1)		
        //테스트 환경에서 DISABLE 사용 처리, 
        // **CSRF(Cross-Site Request Forgery) 공격에 대한 Spring Security에 대한 설정을 비활성화**
        http.csrf().disable() 
                .formLogin() //(2) 
                .loginPage("/auths/login-form") //(3)
                //로그인페이지 사용하는 설정
                .loginProcessingUrl("process_login")
                //로그인을 실제로 수행할 주소 (인증)
                .failureUrl("/atuhs/login-form?error")
                //실제 로그인이 실패했을 경우 어떤 페이지를 보낼 건지. 어떻게 처리할건지 설
                .and()
                .authorizeHttpRequests() //클라이언트의 요청이 들어오면 접근 권한을 확인
                .anyRequest()
                .permitAll();
                    //클라이언트의 권한을 볼건데 전체 다 가능
        return http.build();
    }
```

1. (1) 에서  **CSRF(Cross-Site Request Forgery) 공격에 대한 Spring Security에 대한 설정을 비활성화**
    - Spring Security는 기본적으로 아무 설정을 하지 않으면 csrf() 공격을 방지하기 위해 클라이언트로부터 CSRF Token을 수신 후, 검증한다.
    - but 우리는 로컬환경이라서 공격에 대한 설정이 따로 필요하지 않음
2. (2) 에서 기본적인 인증 방법을 폼로그인 방식으로 지정
3. (3)의 .loginPage("/auths/login-form") 에서 해당 파라미터의 URL은 AuthController의 loginForm() 핸들러 메서드에 요청을 전송하는 URL이다.
4. 마찬가지로 loginProcessingUrl(**"/process_login"**) 메서드를 통해 로그인 인증 요청을 수행할 요청 URL을 지정 <br/> → "**/process_login**"은 우리가 만들어 둔 login.html에서 form 태그의 action 속성에 지정한 URL과 동일
    - 커스텀 로그인 화면에서 로그인 버튼을 클릭하면 <br/> form태그의 action속성에 지정된 /process_login URL로 사용자 인증을 위한 정보를 전송(이메일과 패스워드)

### 3️⃣ 커스텀 로그인 페이지(login.html)의 인증실패 메세지 추가

`${param.error}`의 값을 통해 로그인 인증 실패 메시지 표시 여부를 결정

`${param.error}`는  Spring Security Configuration에서 <br/>  
<span style="color:Green">failureUrl("/auths/login-form?error")의 ?error</span> 부분에 해당하는 쿼리 파라미터를 의미

```java
<div class="row alert alert-danger center" role="alert" th:if="${param.error != null}">
	<div>로그인 인증에 실패했습니다.</div>
</div>
```

### 4️⃣ 요청 URI에 대한 접근 권한 부여

<span style="color:Green">**SecurityConfiguration에서 filterChain메서드 수정**</span>

```java
@Configuration
public class SecurityConfiguration {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .formLogin()
            .loginPage("/auths/login-form")
            .loginProcessingUrl("/process_login")
            .failureUrl("/auths/login-form?error")
            .and()
            .exceptionHandling().accessDeniedPage("/auths/access-denied")
            .and()
            .authorizeHttpRequests(authorize -> authorize             
                    .antMatchers("/orders/**").hasRole("ADMIN") 
                    .antMatchers("/members/my-page").hasRole("USER")
                    .antMatchers("/**").permitAll()
            );
        return http.build();
    }
```

2️⃣에서 구현된 filterChain()에서 .authorizeHttpRequests().anyRequest().permitAll(); 설정을 통해 로그인 인증에 성공할 경우,<br/> 모든 화면에 접근할 수 있도록 했던 부분을 **사용자의 Role 별로 request URI에 접근 권한이 부여**되도록 수정

1. **exceptionHandling().accessDeniedPage("/auths/access-denied")**를 통해<br/> 권한이 없는 사용자가 특정 request URI에 접근할 경우 발생하는 **403(Forbidden)** 에러를 처리하기 위한 페이지를 설정
    - **exceptionHandling ()** : Exception 처리를 수행
    - 리턴하는 **ExceptionHandlingConfigure 객체**를 통해 구체적인 Exception 처리가능
    - **accessDeniedPage()** 메서드는 403 에러 발생 시, 파라미터로 지정한 URL로 리다이렉트 되도록 해준다.
2. authorizeHttpRequests() 메서드에서 람다식으로 request URI에 대한 접근 권한을 부여
    - `antMatchers()` 메서드는 이름 그대로 **ant**라는 빌드 툴에서 사용되는 `Path Pattern`을 이용해서 매치되는 URL을 표현
    - `**`는 /orders로 시작하는 모든 하위 URL을 포함
    - `orders/*`라는 URL을 지정했다면 `/orders/1`과 같이 /orders의 하위 URL의 depth가 1인 URL만 포함
    - `antMatchers("/members/my-page").hasRole("USER")`은 `USER` Role을 부여받은 사용자만<br/> `/members/my-page` URL에 접근할 수 있다.
    - `.antMatchers("/**").permitAll()`은 앞에서 지정한 URL 이외의 나머지 모든 URL은 Role에 상관없이 접근이 가능함을 의미
3. **antMatchers()를 이용한 접근 권한 부여 시, 주의 사항**
    - 만약에 authorizeHttpRequests() 메서드에서 `.antMatchers("/**").permitAll()` 이 제일 앞에 위치하게 되면 <br/> Role에 상관없이 모든 requestURL에 접근 허용하기 때문에 다음에 오는 접근 권한 조건은 제 기능을 하지 못하게 된다.
    - 항상 ⭐ **더 구체적인 URL 경로부터 접근 권한을 부여한 다음 덜 구체적인 URL 경로에 접근 권한을 부여하는 습관 들이기.**
    
    > 참고로 Ant는 Maven과 Gradle에 밀려서 거의 사용되지 않는 빌드 툴,<br/> but, Ant에서 사용되는 Ant Pattern은 URL 경로 등을 지정하기 위한 Pattern 표현식으로 여러 오픈 소스에서 사용되고 있다.<br/>Maven도 xml을 사용해야해서 gradle로 많이 넘어가는 추세
    

### 5️⃣ 관리자 권한을 가진 사용자 추가

```java
...
@Configuration
public class SecurityConfiguration {
    ...
    ...
    @Bean
    public InMemoryUserDetailsManager userDetailsService() {
        UserDetails user =
                User.withDefaultPasswordEncoder()
                        .username("kevin@gmail.com")
                        .password("1111")
                        .roles("USER")
                        .build();
                        
        UserDetails admin =
                User.withDefaultPasswordEncoder()
                        .username("admin@gmail.com")
                        .password("2222")
                        .roles("ADMIN")
                        .build();

        return new InMemoryUserDetailsManager(user, admin);
    }
}
```

### 6️⃣ 로그인 한 사용자 아이디 표시 및 사용자 로그아웃.

로그인 한 사용자 표시 & 로그인 한 사용자 로그아웃 하기 & 마이페이지 링크는 로그인 한 사용자에게만 보이게 하기

1. header.html 수정 → 로그아웃 및 권한 별 메뉴표시하기
    
    ```html
    <html xmlns:th="<http://www.thymeleaf.org>"
          xmlns:sec="<http://www.thymeleaf.org/thymeleaf-extras-springsecurity5>"> 
          <!-- (1) -->
        <body>
            <div align="right" th:fragment="header">
                <a href="/members/register" class="text-decoration-none">회원가입</a> |
                <span sec:authorize="isAuthenticated()"> <!-- (2) -->
                    <span sec:authorize="hasRole('USER')">  <!-- (3) -->
                        <a href="/members/my-page" class="text-decoration-none">마이페이지</a> |
                    </span>
                    <a href="/logout" class="text-decoration-none">로그아웃</a>  <!-- (4) -->
                    <span th:text="${#authentication.name}">홍길동</span>님  <!-- (5) -->
                </span>
    
                <span sec:authorize="!isAuthenticated()"> <!-- (6) -->
                    <a href="/auths/login-form" class="text-decoration-none">로그인</a>
                </span>
            </div>
        </body>
    </html>
    
    ```
    
    - 타임리프 기반의 HTML 템플릿에서 사용자의 인증 정보나 권한 정보를 이용해 어떤 로직을 처리하기 위해서는 <br/> 먼저 **(1)**과 같이 `sec` 태그를 사용하기 위한 XML 네임스페이스를 지정, 지정하지 않아도 동작하지만 태그에 에러 표시 남.
    - **(2) :** <span> 태그 내부에서 `sec:authorize="isAuthenticated()"`를 지정하면 현재 페이지에 접근한 사용자가 인증에 성공한 사용자인지를 체크
        - ⇒ `isAuthenticated()`의 값이 `true`이면  <span> 태그 하위에 포함된 콘텐츠를 화면에 표시
    - **(3)** : 인증에 성공한 사용자라면 마이페이지는 USER Role을 가진 사용자에게만 표시 되도록 한다.
    - **(4)** : (2)에서 로그인에 성공한 사용자는 [로그인] 메뉴 대신 [로그아웃]이 표시된다.
        - `href="/logout"`에서 <span style="color:Green"> “/logout” URL은 SecutiryConfiguration 클래스에서 설정한 값</span>과 같아야 한다.
    - **(5) :** `th:text="${#authentication.name}"`를 통해 로그인 사용자의 username을 표시 → 로그인 한 사용자는 username이 표시되고
    - **(6) :** sec:authorize="!isAuthenticated()"를 통해 로그인 한 사용자가 아니라면 [로그인] 버튼이 표시되도록 한다.
        - sec 태그 사용시  build.gradle에서 의존 라이브러리 추가 해야함
        - implementation 'org.thymeleaf.extras:thymeleaf-extras-springsecurity5'
    
    <br/>
2. **SecurityConfiguration  클래스에 로그아웃 설정 추가**
    - 로그아웃을 눌렀을 때는 스프링 은 로그아웃 url을 설정 시 기본적으로 권한이 사라지게 설정 되어 있음. → 로그인 페이지로 이동하게 되어있음,
    - 우리가 로그아웃을 설정하면  성공했을 때 루트로 이동하게 코드 추가.
        
        <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/c8116d74-7be8-4b63-a7af-3f71f57142ae" width=400/>
        
    - logout() 메서드는 로그아웃 설정을 위한 `LogoutConfigurer`를 리턴
    - logoutUrl("/logout")을 통해 사용자가 로그아웃을 수행하기 위한 request URL을 지정 <br/> ⇒ ⭐ 여기서 설정한 URL은 header.html의 로그아웃 메뉴에 지정한 `href="/logout"`과 동일해야 한다.
    - .logoutSuccessUrl("/") : 로그아웃을 성공적으로 수행한 이후 리다이렉트 할 URL을 지정, 여기서는 메인화면으로 리다이렉트 하도록 지정.
    - 로그아웃 클릭 시 헤더가 바뀌게 됨.
        
        <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/a1b0706e-cdfe-44fb-9225-8eb3ac5901b3" width=200/>
        

# 회원가입 기능 구현

여기까지 Security filterChain으로 인증인가를 구현  → 이제  인메모리DB로 변경

<img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/b69da58c-af3b-4692-905e-71a5c2344d07" width=500/>

이 UserDetails객체가 새로 생성되어야함 

아직DB는 사용하지 않을 것이기 때문에 InMemoryUserDetailsManager로 반환할 예정

### **[회원 가입 폼을 통한 InMemory User 등록]**

회원 가입 폼을 통해 InMemory User를 등록하기 위한 작업 순서

- PasswordEncoder Bean 등록
- MemberService Bean 등록을 위한 JavaConfiguration 구성
- InMemoryMemberService 클래스 구현

### 1️⃣ **PasswordEncoder Bean 등록**

PasswordEncoder는 Spring Security에서 제공하는 패스워드 암호화 기능을 제공하는 컴포넌트이다.

> PasswordEncoder는 다양한 암호화 방식을 제공하며,<br/> Spring Security에서 지원하는 PasswordEncoder의 디폴트 암호화 알고리즘은 bcrypt이다.
> 

<img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/a847658c-f4e0-46ca-bdf5-86a3cf320cab" width=400>

- 회원 가입 폼을 통해 애플리케이션에 전달되는 패스워드는 암호화되지 않은 플레인 텍스트(Plain Text)<br/> → 암호화하기위해 passwordEncorder사용
- **회원 가입 폼에서 전달받은 패스워드는 InMemory User로 등록하기 전에 암호화되어야 한다.**
<br/>

<span style="color:Blue">**SecurityConfiguration 클래스에서 PasswordEncoder를 Bean으로 등록**</span>

```java
@Configuration
public class SecurityConfiguration {
...

@Bean
public PasswordEncoder passwordEncoder(){
    return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }
}
```

`PasswordEncoderFactories.createDelegatingPasswordEncoder();`를 통해 `DelegatingPasswordEncoder`를 먼저 생성하는데,<br/> 이 `DelegatingPasswordEncoder`가 실질적으로 **PasswordEncoder** 구현 객체를 생성해 준다.

> **참고)** 개발환경에서만 인메모리 DB 사용할 거고 @configuration으로 빈객체를 만드는 것임. @Configuration+@bean을 사용하지않고 @Component 사용 해도 됨.
> 

### 2️⃣ MemberService Bean 등록을 위한 JavaConfiguration 구성

1. MemberSercice
    
    회원 가입 폼에서 전달받은 정보를 이용해 새로운 사용자를 추가하는 기능만 있으면 되므로 `createMember()` 하나만 구현하는 구현체가 있으면 된다.
    
    ```java
    package com.springboot.member;
    
    public interface MemberService {
        Member createMember(Member member);
    }
    
    ```
    
2. **InMemoryMemberService** → MemberService 인터페이스를 구현하는 구현 클래스
    
    ```java
    package com.springboot.member;
    
    public class InMemoryMemberService implements MemberService {
        public Member createMember(Member member) {
    
            return null; // 뒤에서 구현 할 예정이다.
        }
    }
    
    ```
    
3. **DBMemberService 클래스 → 데이터베이스에 User를 등록**하기 위한 MemberService 인터페이스의 구현 클래스
    
    ```java
    package com.springboot.member;
    
    import org.springframework.transaction.annotation.Transactional;
    
    @Transactional
    public class DBMemberService implements MemberService {
        public Member createMember(Member member) {
             return null; // InMemory User 등록이 끝난 다음 학습내용,  이어서 바로 구현
        }
    }
    
    ```
    

1. **JavaConfiguration 구성 :**  MemberService Bean 등록을 위한 JavaConfiguration 구성
    
    ```java
    package com.springboot.config;
    
    import com.springboot.member.InMemoryMemberService;
    import com.springboot.member.MemberService;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import org.springframework.security.provisioning.UserDetailsManager;
    
    @Configuration
    public class JavaConfiguration {
        
        @Bean
        public MemberService inMemoryMemberService(UserDetailsManager userDetailsManager,
                                                   PasswordEncoder passwordEncoder) {
            return new InMemoryMemberService(userDetailsManager, passwordEncoder);
        }
    }
    
    ```
    
    - MemberService 인터페이스의 구현 클래스인 InMemoryMemberService를 Spring Bean으로 등록
    - **데이터베이스 연동 없이 메모리에 Spring Security의 User를 등록**해야 하므로 `UserDetailsManager` 객체가 필요
    - User 등록 시, **패스워드를 암호화한 후에 등록**해야 하므로 Spring Security에서 제공하는 `PasswordEncoder` 객체가 필요
    - 두 객체를 InMemoryMemberService 객체 생성 시, DI 해 주어야 한다.
    

### **3️⃣ InMemoryMemberService 구현**

```java
package com.springboot.member;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.UserDetailsManager;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

//(1) @Service 애너테이션은 여기에 달지 않는다, 중복안됨. 바로 위 JavaConfiguration에서 반환되는 
// InMemoryMemberService가 빈으로 등록되었기 때문.
public class InMemoryMemberService implements MemberService {
     //(2)
    private final UserDetailsManager userDetailsManager;
  
    private final PasswordEncoder passwordEncoder;

    public InMemoryMemberService(UserDetailsManager userDetailsManager, PasswordEncoder passwordEncoder) {
        this.userDetailsManager = userDetailsManager;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    public Member createMember(Member member) {
		  //(3)
        List<GrantedAuthority> authorities = createAuthories(Member.MemberRole.ROLE_USER.name());
        //일반적인 회원가입은 user로 권한 설정해줌
        //파라미터로 들어온 member는 dto에서 변환 된 것 , 비밀번호는 아직 평문이다. 암호화해야 함.
        //인가는 List로 관리 한다..

        String encryptedPassword = passwordEncoder.encode(member.getPassword());
       
       //(4)
        UserDetails userDetails = new User(member.getEmail(), encryptedPassword, authorities);
                                    //우리가 만든 유저 아님.

        userDetailsManager.createUser(userDetails); 
		        //UserDetailsManager의 createUser() 메서드를 이용해서 User를 등록
        return member;
    }

		//(5) 
    private List<GrantedAuthority> createAuthories(String ...roles){
        return Arrays.stream(roles)
                .map(role-> new SimpleGrantedAuthority(role))
                .collect(Collectors.toList());

        //권한을 리스르토 받는 이유
        //한 사용자가 여러 개의 권한을 가질 수 있기 때문
        //예를 들어, 한 사용자가 ROLE_USER와 ROLE_ADMIN 권한을 동시에 가질 수 있다.
        // 따라서 권한을 리스트로 관리하여 유연하게 여러 권한을 부여할 수 있다.

    }
}

```

- (1) 에서 @Service 애너테이션은  달지 않는다 → 빈은 중복이 되면 안된다. <br> 바로 위 JavaConfiguration에서 반환되는InMemoryMemberService가 빈으로 등록되었기 때문.
- (2)  에서  `UserDetailsManager`와 `PasswordEncoder`를 DI 받는다.
    - UserDetailsManager는 Spring Security의 User를 관리하는 관리자 역할을 한다..
    - SecurityConfiguration에서 빈 설정을 한 이유는 여기서 주입하려고 <br/> ⇒ PSA (Policy Service Abstraction) 원칙에 따라 추상 메서드를 사용하면 메서드 이름을 바꾸지 않고도 일관된 방식으로 주입 가능
    - UserDetailsManager 인터페이스의 하위 타입은`InMemoryUserDetailsManager`라는 사실 기억하기.
- (3) : Spring Security에서 User를 등록하기 위해서는 해당 User의 권한(Authority)을 지정해 주어야 한다.
    - `createAuthorities(Member.MemberRole.ROLE_USER.name());`를 이용해 User의 권한 목록을 `List<GrantedAuthority>`로 생성
    - Member 클래스에는 `MemberRole`이라는 enum이 정의되어있다.
        
        <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/88e6da2f-601c-4089-a426-51c44126f7c3" width=400/>
        
        <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/137c2a33-e11c-4b8a-9962-6b53cf1f59da" width=400/>

        
    - ⭐ Spring Security에서는 `SimpleGrantedAuthority`를 사용해 Role 베이스 형태의 권한을 지정할 때 <br/> `‘ROLE_’ + 권한 명` 형태로 지정해 주어야 한다. 그렇지 않을 경우 적절한 권한 매핑이 이루어지지 않는다는 사실 기억하기
- (4)에서는 Spring Security User로 등록하기 위해 `UserDetails`를 생성한다.
    
    ⭐ Spring Security에서는 Spring Security에서 관리하는 User 정보를 `UserDetails`로 관리한다는 것 꼭 기억하기
    
- (5) 의 createAuthories 메서드 : Stream API를 이용해 생성자 파라미터로 해당 User의 Role을 전달하면서 `SimpleGrantedAuthority` 객체를 생성한 후, `List<SimpleGrantedAuthority>` 형태로 리턴

## 데이터 베이스 연동을 통한 로그인 인증

테스트 환경이므로 DB도 인메모리로 사용할 예정 

### Custom UserDetailsService를 사용하는 방법

Spring Security에서는 User의 인증 정보를 테이블에 저장하고, 테이블에 저장된 인증 정보를 이용해 인증 프로세스를 진행할 수 있는 몇 가지 방법이 있고 그 중 하나가 Custom UserDetailsService를 사용하는 것.

### 1️⃣ **SecurityConfiguration의 설정 변경 및 추가**

1. H2는 데이터베이스 접속을 하기 위해 뷰단에서 SameOrigin설정 해야 볼 수 있음.
    
    ```java
    @Configuration
    public class SecurityConfiguration {
     @Bean
     public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    
            http. headers().frameOptions().sameOrigin()
                    //같은 페이지일 경우 페이지렌더링을 허용하겠다 
                    // 실무에서도 아마 안쓸 확률이 높음.
                .and()
                .csrf().disable()
                .formLogin()
                ...
                ...
                return http.build();
                
    ```
    

1.  데이터베이스에 저장되어 있는 인증 정보를 사용할 것이라서 InMemory User를 위한 설정들은 더 이상 필요 없으므로 제거,<br/> 아래 코드는 다 제거하면 된다.
    
    ```java
        @Bean //스프링 컨테이너의 도움을 받기 위함 => 사실은 javaconfiguration에서 주입하기 위함
        public UserDetailsManager userDetailService(){
    //        UserDetails user =
    //                User.withDefaultPasswordEncoder()
    //                        .username("jerry@gmail.com") 
    //                        .password("wpfl")
    //                        .roles("USER") 
    //                        .build(); 
            UserDetails admin =
                    User.withDefaultPasswordEncoder()
                            .username("admin@gmail.com") //일반적으로 통용되는 아이디의 개념.
                            .password("ehowl")
                            .roles("ADMIN") //인가 : 권한을 뭘 줄 것인지?
                            .build();
            return new InMemoryUserDetailsManager(admin);
       
    
        }
    ```
    



### **2️⃣ JavaConfiguration의 Bean 등록 변경**

 데이터베이스에 User의 정보를 저장하기 위해 MemberService 인터페이스의 구현 클래스를 inMemoryMemberService에서 DBMemberService로 변경

```java
...
@Configuration
public class JavaConfiguration {
    @Bean
    public MemberService inMemoryMemberService(UserDetailsManager userDetailsManager,
                                               PasswordEncoder passwordEncoder) {
        return new InMemoryMemberService(userDetailsManager, passwordEncoder);
    }
}

```

⬇️⬇️     ⬇️⬇️

```java
@Configuration
public class JavaConfiguration {
    // (1)
    @Bean
    public MemberService dbMemberService(MemberRepository memberRepository,
                                         PasswordEncoder passwordEncoder) {
        return new DBMemberService(memberRepository, passwordEncoder); (1-1)
    }
}
```

DBMemberService는 내부에서 데이터를 데이터베이스에 저장하고, <br/> 패스워드를 암호화해야 하므로  `MemberRepository`와 `PasswordEncoder` 객체를 DI 해준다.

### 3️⃣ **DBMemberService 구현**

```java
@Transactional
public class DBMemberService implements MemberService {
    private final MemberRepository memberRepository;
    private final PasswordEncoder passwordEncoder;

    public DBMemberService(MemberRepository memberRepository,
                             PasswordEncoder passwordEncoder) {
        this.memberRepository = memberRepository;
        this.passwordEncoder = passwordEncoder;
    }

    public Member createMember(Member member) {
        verifyExistsEmail(member.getEmail());
        String encryptedPassword = passwordEncoder.encode(member.getPassword());  // (1)
        member.setPassword(encryptedPassword);    // (2)

        Member savedMember = memberRepository.save(member);

        System.out.println("# Create Member in DB");
        return savedMember;
    }

    ...
    ...
}

```

- (1)에서 PasswordEncoder를 이용해 패스워드를 암호화한다.
- (2)에서 암호화된 패스워드를 password 필드에 다시 할당한다.

### **4️⃣ Custom UserDetailsService 구현  - V1**

**데이터베이스에서 조회한 User의 인증 정보를 기반으로 인증을 처리**

> **⭐ UserDetailsService**
> 
> 
> Spring Security에서 제공하는 컴포넌트 중 하나인 `UserDetailsService`는 User 정보를 로드(load)하는 핵심 인터페이스
> 
> 여기서 로드(load)의 의미는 **인증에 필요한 User 정보를 어딘가에서 가지고 온다**는 의미이며, 여기서 말하는 ‘**`어딘가`**’는 메모리가 될 수도 있고, DB 등의 영구 저장소가 될 수도 있습니다.
> 
> 우리가 InMemory User를 등록하는 데 사용했던 InMemoryUserDetailsManager는 UserDetailsManager 인터페이스의 구현체이고, UserDetailsManager는 UserDetailsService를 상속하는 확장 인터페이스


1. **HelloUserDetailsService**

    데이터베이스의 인증 정보로 인증을 처리하는 Custom UserDetailsService
    
    ```java
    @Component
    public class HelloUserDetailsServiceV1 implements UserDetailsService {   // (1)
        private final MemberRepository memberRepository;
        private final HelloAuthorityUtils authorityUtils;
    
        // (2)
        public HelloUserDetailsServiceV1(MemberRepository memberRepository, HelloAuthorityUtils authorityUtils) {
            this.memberRepository = memberRepository;
            this.authorityUtils = authorityUtils;
        }
    
        // (3)
        @Override
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            Optional<Member> optionalMember = memberRepository.findByEmail(username);
            Member findMember = optionalMember.orElseThrow(() -> new BusinessLogicException(ExceptionCode.MEMBER_NOT_FOUND));
    
            // (4)
            Collection<? extends GrantedAuthority> authorities = authorityUtils.createAuthorities(findMember.getEmail());
    
            // (5) 개선하면 좋은 포인트
            return new User(findMember.getEmail(), findMember.getPassword(), authorities);
        }
    }
    ```
    
    - **(1)** :  `UserDetailsService` **인터페이스를 구현한다.**
    - **(2)** : 데이터베이스에서 User를 조회하고, 조회한 User의 권한(Role) 정보를 생성하기 위해 
            `MemberRepository`와 `HelloAuthorityUtils` 클래스를 DI 받는다.
    - `UserDetailsService` 인터페이스를 implements 하는 구현 클래스는 
        **(3)**과 같이 `loadUserByUsername(String username)`이라는 추상 메서드를 구현해야 한다.
    - `HelloAuthorityUtils`를 이용해 데이터베이스에서 조회한 회원의 이메일 정보를 이용해 Role 기반의 권한 정보(`GrantedAuthority`) 컬렉션을 생성한다.
    - **(4)** 에서 생성한 권한 정보를 Spring Security에서는 아직 알지 못하기 때문에 Spring Security에 이 정보들을 제공해 주어야 하며, **(5)** 에서는 `UserDetails` 인터페이스의 구현체인 `User` 클래스의 객체를 통해 제공
    - (5)와 같이 데이터베이스에서 조회한 User 클래스의 객체를 리턴하면 Spring Security가 이 정보를 이용해 인증 절차를 수행한다.
    
    ⭐ **즉, 데이터베이스에서 User의 인증 정보만 Spring Security에 넘겨주고, 인증 처리는 Spring Security가 대신해 준다**
    
    > ⭐ UserDetails
    > 
    > 
    > `UserDetails`는 UserDetailsService에 의해 로드(load)되어 인증을 위해 사용되는 핵심 User 정보를 표현하는 인터페이스이다.
    > 
    > `UserDetails` 인터페이스의 구현체는 Spring Security에서 보안 정보 제공을 목적으로 직접 사용되지는 않고, `Authentication` **객체로 캡슐화되어 제공된다.**
    > 
    <br/>

1.  **HelloAuthorityUtils**
    
    ```java
    package com.springboot.auth.utils;
    
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.security.core.GrantedAuthority;
    import org.springframework.security.core.authority.AuthorityUtils;
    import org.springframework.stereotype.Component;
    import java.util.List;
    
    @Component
    public class HelloAuthorityUtils {
        // (1)
        @Value("${mail.address.admin}")
        private String adminMailAddress;
    
        // (2)
        private final List<GrantedAuthority> ADMIN_ROLES = AuthorityUtils.createAuthorityList("ROLE_ADMIN", "ROLE_USER");
    
        // (3)
        private final List<GrantedAuthority> USER_ROLES = AuthorityUtils.createAuthorityList("ROLE_USER");
    
        public List<GrantedAuthority> createAuthorities(String email) {
            // (4)
            if (email.equals(adminMailAddress)) {
                return ADMIN_ROLES;
            }
            return USER_ROLES;
        }
    }
    
    ```
    
    - (1)은 application.yml에 추가한 프로퍼티를 가져오는 표현식
        
        <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/365b61ce-a957-4dba-96dd-77d7a59598ca" width=300/>
        
        - 이걸 넣는다고 자동으로 관리자권한의 메일이 생성되지 않는다
        - 이걸 설정하면 (4)에서 가입한 사람의 이메일을 검증한다. <br/>⇒  admin으로 넣어둔 이메일과 동일한지, 만약 동일하다면 ADMIN_ROLES를 부여 ,<br/> 아니라면 USER_ROLES → 인가는 로그인 하고 나서 인가가 이루어짐.
        <br/>
            
        > ⭐ 실무에서는 당연히 회원 가입 시, 아무런 인증 장치도 없이 이메일 주소만 입력해서 관리자 권한을 부여하지는 않는다.
        > 
        > 
        > 관리자 권한은 아무리 강조해도 지나치지 않을 정도로 중요!
        > 
        > **관리자로서 등록하기 위한 추가적인 인증 절차**가 있을 것
        >
        <br/> 
    - (4)에서 `List<GrantedAuthority>` 를 리턴하면 회원에게 인가가 부여 됨.
        
        <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/3fa8e4b6-2803-4019-b8b1-02744653e190" width=400/>
        

1. **H2 웹 콘솔에서 등록한 회원 정보 확인 및 로그인 인증 테스트**
    - 회원가입 및 로그인 잘 됨.
        
        <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/4f617f2b-c01c-4da9-88c7-3268cd195660"/>
        
    - h2 console 확인하면 아래와 같이 정보 들어옴
        
       <img src="https://github.com/quokkavely/quokkavely.github.io/assets/165968530/ca07bbcd-43a0-46a7-92a8-d8a80bc563d4"/>
        
        PASSWORD 열을 보면 회원 가입 메뉴에서 입력했던 **패스워드 정보가 암호화 되어있다**
        

### 5️⃣ `HelloUserDetailsServiceV2`생성 

V1에 있던 @Component 는 삭제해야 함. 하나만 있어야 한다.

 UserDetails의 구현 클래스인 User의 객체를 직접적으로 생성해서 리턴하는 부분을 개선할 것.

```java
package com.springboot.auth;

import com.springboot.exception.BusinessLogicException;
import com.springboot.exception.ExceptionCode;
import com.springboot.member.Member;
import com.springboot.member.MemberRepository;
import com.springboot.utils.HelloAuthorityUtils;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.List;
import java.util.Optional;

@Component
public class HelloUserDetailsServiceV2 implements UserDetailsService {
    private final MemberRepository memberRepository;
    private final HelloAuthorityUtils helloAuthorityUtils;

    public HelloUserDetailsServiceV2(MemberRepository memberRepository, HelloAuthorityUtils helloAuthorityUtils) {
        this.memberRepository = memberRepository;
        this.helloAuthorityUtils = helloAuthorityUtils;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //UserDetailsService를 사용하려면 필수로 있어야 하는 메서드
        Optional<Member> optionalMember = memberRepository.findByEmail(username);
        Member findMember = optionalMember.orElseThrow(()-> new BusinessLogicException(ExceptionCode.MEMBER_NOT_FOUND));

        //List<GrantedAuthority> authorities=helloAuthorityUtils.createAuthorities(findMember.getEmail());
        //return new User(findMember.getEmail(), findMember.getPassword(), authorities);
				return new HelloUserDetails(findMember);
    }
    
    
    //------------------------추가한 코드 --------------------------------------

    //이너 클래스 생성 , 인터페이스 구현하면서 엔티티를 상속. 상속이 먼저와야 한다.
    private final class HelloUserDetails  extends Member implements UserDetails{

        //아래 클래스는 멤버를 상속하기 때문에 필드에 없어도 다 가지고 있다 (Member 가 super클래스에 해당)
        // (private로 선언된 것을 제외하고, getter setter는 다 public 이기 때문에 가져오는 것이 가능)
        HelloUserDetails(Member member){
            setMemberId(member.getMemberId());
            setEmail(member.getEmail());
            setFullName(member.getFullName());
            setPassword(member.getPassword());
        }

        @Override
        public Collection<? extends GrantedAuthority> getAuthorities() { //인가정보를 만들어 주어야 함.
            return helloAuthorityUtils.createAuthorities(this.getEmail());//HelloUserDetails의 이메일을 가져오는 것-> this
        }

        @Override
        public String getUsername() {
            return this.getEmail();
        }

//크게 중요하지 않아서 모두 true로 변경
        @Override
        public boolean isAccountNonExpired() {
            return true;
        }

        @Override
        public boolean isAccountNonLocked() {
            return true;
        }

        @Override
        public boolean isCredentialsNonExpired() {
            return true;
        }

        @Override
        public boolean isEnabled() {
            return true;
        }
    }
}

```

- 기존에는 loadUserByUsername() 메서드의 리턴 값으로 <br/> new User(findMember.getEmail(), findMember.getPassword(), authorities);을 리턴했지만<br/> 개선된 코드에서는 (1)과 같이 new HelloUserDetails(findMember);라는 <br/> Custom UserDetails 클래스의 생성자로 findMember를 전달
- (2)의 HelloUserDetails 클래스는 UserDetails 인터페이스를 구현하고 있고 <br/> 또한 Member 엔티티 클래스를 상속하고 있다.
    - loadUserByUsername() 메서드 내부에서 User의 권한 정보를 생성하는 코드도 안으로 들어감.<br/> ⇒ Collection<? extends GrantedAuthority> authorities = authorityUtils.createAuthorities(findMember);도<br/> HelloUserDetails 클래스 내부로 이동

💡 이렇게 구성하면 **데이터베이스에서 조회한 회원 정보를 Spring Security의 User 정보로 변환하는 과정**과 **User의 권한 정보를 생성하는 과정**을 **캡슐화**할 수 있다.

💡 또한 `HelloUserDetails` 클래스는 `Member` 엔티티 클래스를 상속하고 있으므로 HelloUserDetails를 리턴 받아 사용하는 측에서는 두 개 클래스의 객체를 모두 다 손쉽게 캐스팅해서 사용 가능하다

(2-3)에서는 `HelloAuthorityUtils`의 `createAuthorities()` 메서드를 이용해 User의 권한 정보를 생성

이 코드는 기존에는 loadUserByUsername() 메서드 내부에 있었지만 지금은 `HelloUserDetails` 클래스 내부에서 사용되도록 캡슐화되었다.

- (2-4)에서는 Spring Security에서 인식할 수 있는 username을 Member 클래스의 email 주소로 채우고 있기 때문에 <br/> `getUsername()`의 **리턴 값은 null일 수 없다.**
- 기타 UserDetails 인터페이스의 추상 메서드를 구현한 부분은 지금은 크게 중요하지 않은 부분이므로 모두 `true`값을 리턴하게 했다.


### 6️⃣ User의 Role을 DB에서 관리하기

- 일반적으로 User의 인증 정보 같은 보안과 관련된 정보는 데이터베이스 같은 영구 저장소에 안전하게 보관
- but, 현재까지 User의 권한 정보는 데이터베이스에서 관리하는 것이 아니라<br/> 데이터베이스에서 조회한 User 정보를 기준으로 코드상에서 조건에 맞게 생성
- User의 권한 정보를 데이터베이스에서 관리하기 위해서는 다음과 같은 과정 필요
    - User의 권한 정보를 저장하기 위한 테이블 생성
    - 회원 가입 시, User의 권한 정보(Role)를 데이터베이스에 저장하는 작업
    - 로그인 인증 시, User의 권한 정보를 데이터베이스에서 조회하는 작업

1. **User의 권한 정보 테이블 생성**
    - 권한관련 정보는 실무에서 실제로 테이블을 따로 만들어서 관리한다.<br/>(기본키 1번은 admin 나머지는 user)
    - 하나의 멤버는 하나의 권한? no . 하나의 권한은 하나의 멤버만? no ⇒ 다대다
    - 그러나 일대다로 구현할 예정임, member는 스프시큐리티가 관리하기때문에 멤버에게서만 관계구현 하면 됨.
    - **Member에 코드 추가**
        
        ```java
        @ElementCollection(fetch = FetchType.EAGER)
        //권한 관련 테이블에 설정 -> 애너테이션만 달아도 자동으로 테이블이 생성됨.
        ```
        
        - List, Set 같은 컬렉션 타입의 필드는 `@ElementCollection` 애너테이션을 추가하면 <br/> User 권한 정보와 관련된 별도의 엔티티 클래스를 생성하지 않아도 간단하게 매핑 처리가 된다.
        - 이대로 실행하면 자동으로 테이블 생성 되어있는 걸 볼 수 있다.
            
            ![Untitled](%5BSpring%20Security%5D%204da6e26c83fd475ba416aac36ca8c153/Untitled%2023.png)
            
        
2. **회원 가입 시, User의 권한 정보(Role)를 데이터베이스에 저장**
    
    **📌 DBMemberService**
    
    ```java
    @Transactional
    public class DBMemberService implements MemberService {
        ...
        private final HelloAuthorityUtils authorityUtils;
        ...
        public Member createMember(Member member) {
            verifyExistsEmail(member.getEmail());
            String encryptedPassword = passwordEncoder.encode(member.getPassword());
            member.setPassword(encryptedPassword);
    
            // (1) Role을 DB에 저장
            List<String> roles = authorityUtils.createRoles(member.getEmail());
            member.setRoles(roles);
    
            Member savedMember = memberRepository.save(member);
    
            return savedMember;
        }
    
        ...
        ...
    }
    
    ```
    
    **📌`createRoles()` 메서드가 추가된 `HelloAuthorityUtils` 클래스의 코드**
    
    ```java
    package com.springboot.utils;
    
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.security.core.GrantedAuthority;
    import org.springframework.security.core.authority.AuthorityUtils;
    import org.springframework.security.core.authority.SimpleGrantedAuthority;
    import org.springframework.stereotype.Component;
    
    import java.util.List;
    import java.util.stream.Collectors;
    
    @Component
    public class HelloAuthorityUtils {
        @Value("${mail.address.admin}")
        private String adminMailAddress;
        private final List<GrantedAuthority> ADMIN_ROLES= AuthorityUtils.createAuthorityList("ROLE_ADMIN", "ROLE_USER");
        private final List<GrantedAuthority> USER_ROLES =AuthorityUtils.createAuthorityList("ROLE_USER");
        private final List<String> ADMIN_ROLES_STRING = List.of("ADMIN", "USER");
        private final List<String> USER_ROLES_STRING = List.of("USER");
    
        //메모리의 role을 기반으로 권한 정보 생성
        public List<GrantedAuthority> createAuthorities(String email){
            if(email.equals(adminMailAddress)){
                return ADMIN_ROLES;
            }else {
                return USER_ROLES;
            }
        }
    
        //DB에 저장된 Rolse를 기반으로 권한 정보 생성
        public List<GrantedAuthority>createAuthorities(List<String> roles){
            List<GrantedAuthority> authorities = roles.stream().map(role-> new SimpleGrantedAuthority("ROLE_"+role))
                    .collect(Collectors.toList());
            return authorities;
        }
    
        //DB에 저장하기 위한 형태의 roles를 반환하는 메서드
        public List<String>createRoles(String email) {
            if (email.equals(adminMailAddress)) {
                return ADMIN_ROLES_STRING;
            } else {
                return USER_ROLES_STRING;
            }
        }
    }
    ```
    
    **📌  로그인 인증 시, User의 권한 정보를 데이터베이스에서 조회하는 작업**
    
    ```java
    @Component
    public class HelloUserDetailsServiceV3 implements UserDetailsService {
    		...
    		
        private final class HelloUserDetails extends Member implements UserDetails {
            HelloUserDetails(Member member) {
                setMemberId(member.getMemberId());
                setFullName(member.getFullName());
                setEmail(member.getEmail());
                setPassword(member.getPassword());
                setRoles(member.getRoles());        // (1)
            }
    
            @Override
            public Collection<? extends GrantedAuthority> getAuthorities() {
                // (2) DB에 저장된 Role 정보로 User 권한 목록 생성
                return authorityUtils.createAuthorities(this.getRoles());
            }
            ...
            ...
        }
    }
    
    ```
    
    - (1) : HelloUserDetails가 상속하고 있는 Member(`extends Member`)에 데이터베이스에서 조회한 `List<String> roles`를 전달
    - (2) :  다시 Member(`extends Member`)에 전달한 Role 정보를 authorityUtils.createAuthorities() 메서드의 파라미터로 전달해서<br/> 권한 목록(`List<GrantedAuthority>`)을 생성
    - `createAuthorities(List<String> roles)` 메서드가 추가된 `HelloAuthorityUtils` 클래스
        
        ```java
        ...
        
        @Component
        public class HelloAuthorityUtils {
            @Value("${mail.address.admin}")
            private String adminMailAddress;
        
            private final List<GrantedAuthority> ADMIN_ROLES = AuthorityUtils.createAuthorityList("ROLE_ADMIN", "ROLE_USER");
            private final List<GrantedAuthority> USER_ROLES = AuthorityUtils.createAuthorityList("ROLE_USER");
            private final List<String> ADMIN_ROLES_STRING = List.of("ADMIN", "USER");
            private final List<String> USER_ROLES_STRING = List.of("USER");
        
            // 메모리 상의 Role을 기반으로 권한 정보 생성.
            public List<GrantedAuthority> createAuthorities(String email) {
                if (email.equals(adminMailAddress)) {
                    return ADMIN_ROLES;
                }
                return USER_ROLES;
            }
        
            // (1) DB에 저장된 Role을 기반으로 권한 정보 생성
            public List<GrantedAuthority> createAuthorities(List<String> roles) {
               List<GrantedAuthority> authorities = roles.stream()
                       .map(role -> new SimpleGrantedAuthority("ROLE_" + role)) // (2)
                       .collect(Collectors.toList());
               return authorities;
            }
        
            ...
            ...
        }
        
        ```
        
        **데이터베이스에서 가지고 온 Role 목록(`List<String> roles`)을 그대로 이용해서 권한 목록(`authorities`)을 만든다.**
        
        💡 주의해야 할 것 :  (2)와 같이 `SimpleGrantedAuthority` 객체를 생성할 때 생성자 파라미터로 넘겨주는 값이<br/> “ `USER`"  또는 “`ADMIN`"으로 넘겨주면 안 되고 “`ROLE_USER`" 또는 “`ROLE_ADMIN`" 형태로 넘겨주어야 한다
        
    
### 7️⃣ Custom AuthenticationProvider를 사용하는 방법
    
- Custom UserDetailsService를 사용해 로그인 인증을 처리하는 방식은 **Spring Security가 내부적으로 인증을 대신 처리해 주는 방식**
 - **Custom AuthenticationProvider**를 이용해 우리가 직접 로그인 인증을 처리할 것.
        
        
    1. **HelloUserAuthenticationProvider 클래스**
        - **AuthenticationProvider를 구현한 구현 클래스가 Spring Bean으로 등록되어 있다면<br/> 해당 AuthenticationProvider를 이용해서 인증을 진행**
            - 따라서 클라이언트 쪽에서 로그인 인증을 시도하면 우리가 구현한 HelloUserAuthenticationProvider가 직접 인증을 처리
        
        ```java
        package com.springboot.utils;
        
        import com.springboot.auth.HelloUserDetailsServiceV2;
        import org.springframework.security.authentication.AuthenticationProvider;
        import org.springframework.security.authentication.BadCredentialsException;
        import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
        import org.springframework.security.core.Authentication;
        import org.springframework.security.core.AuthenticationException;
        import org.springframework.security.core.GrantedAuthority;
        import org.springframework.security.core.userdetails.UserDetails;
        import org.springframework.security.core.userdetails.UsernameNotFoundException;
        import org.springframework.security.crypto.password.PasswordEncoder;
        import org.springframework.stereotype.Component;
        
        import java.util.Collection;
        import java.util.Optional;
        
        @Component
        public class HelloUserAuthenticationProvider implements AuthenticationProvider {
            private final HelloUserDetailsServiceV2 helloUserDetailsServiceV2;
            private final PasswordEncoder passwordEncoder;
        
            public HelloUserAuthenticationProvider(HelloUserDetailsServiceV2 helloUserDetailsServiceV2, PasswordEncoder passwordEncoder) {
                this.helloUserDetailsServiceV2 = helloUserDetailsServiceV2;
                this.passwordEncoder = passwordEncoder;
            }
        
            @Override
            public Authentication authenticate(Authentication authentication) throws AuthenticationException {
                UsernamePasswordAuthenticationToken authToken = (UsernamePasswordAuthenticationToken) authentication;
                String username = authToken.getName();
        
                Optional.ofNullable(username).orElseThrow(()-> new UsernameNotFoundException("Invalid User name or User Password"));
               
               // (2) 회원가입을 하지 않고 로그인하면 생기는 문제점 개선
                try {
                    UserDetails userDetails = helloUserDetailsServiceV2.loadUserByUsername(username);
                    String password = userDetails.getPassword();
                    //암호화 안되어있음
                    
                    
                    verifyCredentials(authToken.getCredentials(), password);
                    //로그인 정보에 포함된 패스워드와 DB에 저장된 패스워드 정보가 일치하는증
                    //verifyCredentials 에서 암호화 이루어짐(단방향 암호화 - 일반적으로 복구가 불가능)
        
                    Collection<? extends GrantedAuthority> authorities = userDetails.getAuthorities();
                    return UsernamePasswordAuthenticationToken.authenticated(username, password, authorities);
                }catch (Exception e){
                    throw new UsernameNotFoundException(e.getMessage());
                }
            }
            
            //support메서드는 우리가 만든 프로바이더가 User기반의 password 방식이라고 스프링 시큐리티에 알려주는 것,
            // 애초에 구현되어 있는 메서드라서 방식에 맞춰서 사용하기.
            //supports() 메서드의 리턴값이 true일 경우, Spring Security는 해당 AuthenticationProvider의 authenticate() 메서드를 호출해서 인증을 진행
            @Override
            public boolean supports(Class<?> authentication) {
                return UsernamePasswordAuthenticationToken.class.equals(authentication);
            }
        
            private void verifyCredentials(Object credentials, String password){
                if(!passwordEncoder.matches((String) credentials, password)){
                    //인코딩 한다음에 둘다 암호화를 한다.(단방향 암호화 - 일반적으로 복구가 불가능)
                    // 같으면 true, 다르면 false
                    throw new BadCredentialsException("Invaild User name or User Password");
                }
            }
        }
        
        ```
        
    
    1. Custom AuthenticationProvider를 이용할 경우 회원가입 전 로그인 하면 나타는 문제점
        - 회원가입을 하지 않은 채로 로그인을 하면 아래와 같은 화면이 나타난다.
            
            ![Untitled](%5BSpring%20Security%5D%204da6e26c83fd475ba416aac36ca8c153/Untitled%2024.png)
            
        - 컨트롤러를 거치지 않아서 BusinessLogicException을 처리하지 못함.
        - filterChain의 가장 끝까지 올라간 후 서블릿을 지나 클라이언트의 요청 최상단으로 가게 됨⇒ 즉, 톰캣에서 발생한 예외이다
        
        개선하려면 .Cusotm AuthenticationProvider에서 Exception이 발생할 경우, 이 Exception을 catch 해서 **AuthenticationException으로 rethrow를 해주면 된다. ⇒**(2) 에서 try-catch로 감싼 이유는 예외를 던져 개선하기함