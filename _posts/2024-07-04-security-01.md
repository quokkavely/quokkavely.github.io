# 240704

인증인가 차이는 알아야 함.

## Spring Security 란?

애플리케이션에 Security를 적용하지 않으면

1. 로그인 기능 (인증,Authentication)이 없음.
2. API 에 대한 권한 부여(인가, Athorization)기능이 없음.

인증과 인가중에 뭐가 먼저 진행? → 인증이 먼저- 그다음 인가처리를 하고 보냄

1. 웹 보안 취약점에 대한 대비가 전혀 이루어지지 않았음, 즉, 웹 애플리케이션을 위협하는 세션 고정 공격, 클릭재킹 공격, CSRF 등의 보안 취약점에 대한 고려가 전혀 이루어지지 않은 상태이다.

### Spring Security

Spring MVC 기반 애플리케이션의 인증(Authentication)과 인가(Authorization or 권한 부여) 기능을 지원하는 보안 프레임워크로써,  Spring MVC 기반 애플리케이션에 보안을 적용하기 위한 사실상의 표준

Spring에서 지원하는 Interceptor나 Servlet Filter를 이용해서 보안 기능을 직접 구현할 수 있지만  웹 애플리케이션 보안을 대부분의 기능을 Spring Security에서 안정적으로 지원하고 있으므로 구조적으로 잘 만들어진 검증된 Spring Security를 이용하는 것이 안전한 선택

### Interceptor와 Filter

![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled.png)

- interceptor는 컨트롤러로 막넘어가기 직전에 가로채서 처리하고 보내줌. (보완관련 이슈처리, 인증-인가) , 그런데 interceptor 사용 안함.
- filter는 브라우저에서 디스패쳐 서블릿으로 넘어가기 직전에 처리한다.
- 기본적으로 filter기반으로 구현한다.
- 디스 패처 서블릿으로 처리를해야 주입된 애들을 관리할 수 있는데. 앞에서 처리할 경우(필터)예전에는 아예 스프링 컨테이너에서 사용하는 기능을 못썼는데 요즘은 지원되고 있는 상태.
- 6버전 부터는 람다식을 사용 , 아직 6버전을 사용하는 곳이 많지 않아서 5.8버전으로 공부할 예정.

### Spring Security로 할 수 있는 보안 강화 기능

Spring Security를 애플리케이션에 적용하면 다음과 같은 일들을 할 수 있다.

- 다양한 유형(**폼 로그인 인증**, **토큰 기반 인증**, **OAuth 2 기반 인증**, LDAP 인증)의 사용자 인증 기능 적용
- **애플리케이션 사용자의 역할(Role)에 따른 권한 레벨 적용**
- **애플리케이션에서 제공하는 리소스에 대한 접근 제어**
- **민감한 정보에 대한 데이터 암호화**
- SSL 적용
- 일반적으로 알려진 웹 보안 공격 차단

이 외에도 SSO, 클라이언트 인증서 기반 인증, 메서드 보안, 접근 제어 목록(Access Control List) 같은 보안을 위한 기능들을 지원한다.

### Spring Security에서 사용하는 용어 정리

- **Principal(주체) → 누가(who?)라고 생각하면 됨.**
    - Spring Security에서 사용되는 `Principal`은 애플리케이션에서 작업을 수행할 수 있는 사용자, 디바이스 또는 시스템 등이 될 수 있으며, 일반적으로 인증 프로세스가 성공적으로 수행된 사용자의 계정 정보를 의미한다.
    - 신원증명이랑은 별개 ⇒ 이건 credential이라고 함 .
- **Authentication(인증)**
    - 애플리케이션을 사용하는 사용자가 본인이 맞음을 증명하는 절차를 의미
    - 정상적으로 수행하기 위해서는 사용자를 식별하기 위한 정보가 필요한데 이를 `Credential`(신원 증명 정보)이라고 한다.
    - `Credential` 은 일상에서 대표적인 예로 주민등록증,  특정 사이트에서 로그인을 위해 입력하는 **패스워드도** 로그인 아이디를 증명하기위한 Credential이다.
- **Authorization(인가 또는 권한 부여)**
    - Authentication이 정상적으로 수행된 사용자에게 하나 이상의 권한(authority)을 부여하여 특정 애플리케이션의 특정 리소스에 접근할 수 있게 허가하는 과정을 의미한다.
    - 반드시 Authentication 과정 이후 수행되어야 하며 권한은 일반적으로 역할(Role) 형태로 부여된다.
- **Access Control(접근 제어)**
    - 사용자가 애플리케이션의 리소스에 접근하는 행위를 제어하는 것을 의미
- 심화 학습 (블로그 노노)
    - 세션 고정(session fixation) 공격에 대해서 더 알아보고 싶다면 아래 링크를 참고하세요.
        - [https://owasp.org/www-community/attacks/Session_fixation](https://owasp.org/www-community/attacks/Session_fixation)
    - 클릭재킹 공격에 대해서 더 알아보고 싶다면 아래 링크를 참고하세요.
        - [https://ko.wikipedia.org/wiki/클릭재킹](https://ko.wikipedia.org/wiki/%ED%81%B4%EB%A6%AD%EC%9E%AC%ED%82%B9)
    - CSRF에서 대해서 더 알아보고 싶다면 아래 링크를 참고하세요.
        - [https://namu.wiki/w/CSRF](https://namu.wiki/w/CSRF)

### Spring Security를 사용해야 하는 이유

- **보안을 강화하기 위한 솔루션으로 Spring Security 만 한 다른 프레임워크가 존재하지 않기 때문**
- Spring Security는 특정 보안 요구 사항을 만족하기 위한 커스터마이징이 용이하고, 유연한 확장이 가능하다. → 커스터마이징이 어려운 경우가 많음.
- Spring Security가 두 세가지 보안 프레임워크를 붙인 것보다 더 나은 경우가 대다수.

# Spring Security의 인증처리 흐름

SSR로 구현, 서서히 개선해 나갈 예정

### SSR과 CSR

1. **SSR**(Server Side Rendering) 방식의 애플리케이션은 세션 기반의 폼 로그인 방식을 적용하기 가장 적합한 애플리케이션이며, 또한 폼 로그인 방식은 Spring Security에 처음 입문하는 사람들이 이해하기에 가장 적합한 인증 방식
    1. ⭐ CSR(Client Side Rendering) 방식으로 이때동안 애플리케이션 구현 해왔지만,  Spring Security를 입문하기 위해 SSR 방식 사용

### Hello Spring Security 샘플 애플리케이션의 구조

HTML 뷰를 구성하기 위해 **타임리프(Thymeleaf)**라는 템플릿 엔진을 사용

![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%201.png)

1. **Header**
    
    ```java
    <html xmlns:th="<http://www.thymeleaf.org>"
          xmlns:sec="<http://www.thymeleaf.org/thymeleaf-extras-springsecurity5>"> <!-- (1) -->
    <body>
    <div align="right" th:fragment="header">
        <a href="/members/register" class="text-decoration-none">회원가입</a> |
        <span sec:authorize="isAuthenticated()"> <!-- (2) 인증이 되었으면 보여지는 것들. -->
                    <span sec:authorize="hasRole('USER')">  <!-- (3) -->
                        <a href="/members/my-page" class="text-decoration-none">마이페이지</a> |
                    </span>
                    <a href="/logout" class="text-decoration-none">로그아웃</a>  <!-- (4) -->
                    <span th:text="${#authentication.name}">홍길동</span>님  <!-- (5) -->
                </span>
    
        <span sec:authorize="!isAuthenticated()"> <!-- (6) 인증이 되지 않았으면 -->
                    <a href="/auths/login-form" class="text-decoration-none">로그인</a>
                </span>
    </div>
    </body>
    </html>
    ```
    
2. **회원가입 HTML**
    
    ```java
    <!DOCTYPE html>
    <html xmlns:th="<http://www.thymeleaf.org>"
          xmlns:layout="<http://www.ultraq.net.nz/thymeleaf/layout>"
          layout:decorate="layouts/common-layout">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Hello Spring Security Coffee Shop</title>
    </head>
    <body>
        <hr />
        <div class="container" layout:fragment="content">
            <!-- (1) 회원 가입 폼 -->
            <form action="/members/register" method="post">
                <div class="row">
                    <div class="col-xs-2">
                        <input type="text" name="fullName" class="form-control" placeholder="User Name"/>
                    </div>
                </div>
                <div class="row" style="margin-top: 20px">
                    <div class="col-xs-2">
                        <input type="email" name="email" class="form-control" placeholder="Email"/>
                    </div>
                </div>
                <div class="row" style="margin-top: 20px">
                    <div class="col-xs-2">
                        <input type="password" name="password" class="form-control" placeholder="Password"/>
                    </div>
                </div>
    
                <button class="btn btn-outline-secondary" style="margin-top: 20px">회원 가입</button>
            </form>
        </div>
    </body>
    </html>
    
    ```
    
3. **로그인**
    
    ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%202.png)
    
    ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%203.png)
    
    로그인 화면 역시 HTML form 태그로 구성이 되어 있으며, HTML의 form 방식으로 로그인 인증을 진행하기 때문에 Spring Security에서도 이러한 인증 방식을 **폼 로그인 인증**
    
4. 서브사이드렌더링 방식이기 때문에 객체를 보내지 않는다.
    
    ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%204.png)
    

### 문제점

- 로그인 기능이 구체적으로 구현되어 있지 않음. → 인증, 인가를 구현해야 함,
    
    ```java
    package com.springboot.auth;
    
    import org.springframework.stereotype.Controller;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestMapping;
    
    @Controller
    @RequestMapping("/auths")
    public class AuthController {
        @GetMapping("/login-form")
        public String loginForm() {
            return "login";
        }
    
        @GetMapping("/access-denied")
        public String accessDenied() {
            return "access-denied";
        }
    
        // (1)
        @PostMapping("/login")
        public String login() {
            System.out.println("Login successfully!");
            return "home";
        }
    }
    
    ```
    
    로그인 인증이 정상적으로 이루어지지 않기 때문에 **커피를 주문하는 회원이든, 매장에서 커피를 만들어서 제공하는 카페 관계자이든 상관없이 모든 화면에 자유롭게 접근할 수 있다.**
    

## 애플리케이션에 Spring Security 적용

1. gradle에 주석처리 되어있는 인증인가를 해제하여 의존주입한다.
    
    ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%205.png)
    

- 원래 HomeController에서 기본 url로 이동시 home으로 가게 설정되어있는데 스프링 시큐리티를 적용하면 기본으로 제공해주는 기능은 첫 홈 화면이 로그인 화면으로 바뀐다.
    
    ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%206.png)
    

- 로그인할 때 아이디는 기본으로 user이고 비밀번호는 프로그램 실행시 제공된다(매번 달라짐)
    
    ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%207.png)
    

- 내 마음대로 아이디와 비밀 번호를 적으면 실패까지 알려준다.
    
    ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%208.png)
    
- 실무에 적용하기 힘듬 → 접속할 때마다 비밀번호가 바뀌게 되니까 로그인 해서 들어가면 로그인 화면이  또 있다(내가 구현한 것)
- 스프링에서 기본으로 제공해주는 첫 화면의 로그인화면과 내가 구현한 로그인 화면 두 개가 중복해서 생기게 됨.

### 1️⃣ 비밀번호 설정 변경

 ⭐ **Spring Security Configuration 적용 →** 클래스에서 Spring Security에서 지원하는 인증과 권한 부여 설정하기

- 프로그램 설정시 생성되는 비밀번호가 아닌
- 매번 비밀번호가 바뀌는 것을 다시 설정할 예정, db는 인메모리 사용

**securityConfiguration** 

```java
package com.springboot.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.provisioning.UserDetailsManager;

@Configuration //Configuration과 빈이 있으면 반환하는 객체를 빈으로 등록하게 됨.
public class SecurityConfiguration {
    @Bean //스프링 컨테이너의 도움을 받기 위함
    public UserDetailsManager userDetailService(){
        UserDetails userDetails =
                User.withDefaultPasswordEncoder()
                        .username("jerry@gmail.com") //일반적으로 통용되는 아이디의 개념.
                        .password("wpfl")
                        .roles("USER") //인가 : 권한을 뭘 줄 것인지?
                        .build(); // 3가지를 담고 빌드하면
        return new InMemoryUserDetailsManager(userDetails);
        //유저객체가 나온다.
        // 메서드명을 보면 UserDetalis를 관리하는 역할을 하는 매니저로 반환해야 하는데
        // 인메모리 매니저로 반환함. 인터페이스로 구현되어있고 추상화 되어있기 때문
        // 데이터베이스를 실제로 사용하지 않고 있기 때문에 인메모리DB의 구현체로 사용
        // 빈은 userDetailService라는 메서드 명으로 등록하게 된다.

    }
}

```

1. `UserDetails` 인터페이스는 인증된 사용자의 핵심 정보를 포함하고 있으며, UserDetails 구현체인  User 클래스를 이용해서 사용자의 인증 정보를 생성한다.
    - UserDetails
        
        ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%209.png)
        
    - User
        
        ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2010.png)
        
        - 여기서 username은 사람의 이름이 아닌 고유한 사용자를 식별할 수 있는 사용자 아이디 같은 값
        
        **User class에 있는 static Method → withDefaultPasswordEncorder( )** 
        
        ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2011.png)
        
        - **withDefaultPasswordEncorder( ) 로 인해 암호화 된다.**
            
            API 문서에서 해당 메서드에는 더이상 사용하지말라는 **@Deprecated** 이 달려있지만→ 실제 서비스환경에서는 사용하지 말라는 의미로 애너테이션이 달려있는 것 - 지금 연습단계라서 의미 둘 필요 없고 하나씩 개선예정
            
2. 반환은UserDetailsManager로 해야하는데,  InMemoryUserDetailsManager로 반환함. 
    - 인터페이스로 구현되어있고 추상화 되어있기 때문
        
        ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2012.png)
        

### 2️⃣ 커스텀 로그인 페이지 사용, 폼로그인 구현 (**HTTP 보안 구성)**.

**SecurityConfiguration**에 filterChain 메서드를 생성 ⇒ HttpSecurity를 파라미터로 가지고, SecurityFilterChain을 리턴하는 형태의 메서드를 정의하면 HTTP 보안 설정을 구성할 수 있다

```java
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        //httpsecurity : 웹보안을 위해서 사용되는 클래스
        //로그인이 또 있으니까 내가 구현한 로그인페이지로 사용하도록 하게 변경하기 위해서 메서드만듬
        //폼로그인으로 구현되어 있기 때문에 폼로그인으로 사용예정
						
				//(1)		
        //테스트 환경에서 DISABLE 사용 처리, 
        // **CSRF(Cross-Site Request Forgery) 공격에 대한 Spring Security에 대한 설정을 비활성화**
        http.csrf().disable() 
                .formLogin() //(2) 
                .loginPage("/auths/login-form") //(3)
                //로그인페이지 사용하는 설정
                .loginProcessingUrl("process_login")
                //로그인을 실제로 수행할 주소 (인증)
                .failureUrl("/atuhs/login-form?error")
                //실제 로그인이 실패했을 경우 어떤 페이지를 보낼 건지. 어떻게 처리할건지 설
                .and()
                .authorizeHttpRequests() //클라이언트의 요청이 들어오면 접근 권한을 확인
                .anyRequest()
                .permitAll();
                    //클라이언트의 권한을 볼건데 전체 다 가능
        return http.build();
    }
```

1. (1) 에서  **CSRF(Cross-Site Request Forgery) 공격에 대한 Spring Security에 대한 설정을 비활성화**
    - Spring Security는 기본적으로 아무 설정을 하지 않으면 csrf() 공격을 방지하기 위해 클라이언트로부터 CSRF Token을 수신 후, 검증한다.
    - but 우리는 로컬환경이라서 공격에 대한 설정이 따로 필요하지 않음
2. (2) 에서 기본적인 인증 방법을 폼로그인 방식으로 지정
3. (3)의 .loginPage("/auths/login-form") 에서 해당 파라미터의 URL은 AuthController의 loginForm() 핸들러 메서드에 요청을 전송하는 URL이다.
4. 마찬가지로 loginProcessingUrl(**"/process_login"**) 메서드를 통해 로그인 인증 요청을 수행할 요청 URL을 지정 → "**/process_login**"은 우리가 만들어 둔 login.html에서 form 태그의 action 속성에 지정한 URL과 동일
    - 커스텀 로그인 화면에서 로그인 버튼을 클릭하면 fom태그의 action속성에 지정된 /process_login URL로 사용자 인증을 위한 정보를 전송(이메일과 패스워드)

### 3️⃣ 커스텀 로그인 페이지(login.html)의 인증실패 메세지 추가

`${param.error}`의 값을 통해 로그인 인증 실패 메시지 표시 여부를 결정

`${param.error}`는  Spring Security Configuration에서 `failureUrl("/auths/login-form?error")`의 `?error` 부분에 해당하는 쿼리 파라미터를 의미

```java
<div class="row alert alert-danger center" role="alert" th:if="${param.error != null}">
	<div>로그인 인증에 실패했습니다.</div>
</div>
```

### 4️⃣ 요청 URI에 대한 접근 권한 부여

**SecurityConfiguration에서 filterChain메서드 수정**

```java
@Configuration
public class SecurityConfiguration {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .formLogin()
            .loginPage("/auths/login-form")
            .loginProcessingUrl("/process_login")
            .failureUrl("/auths/login-form?error")
            .and()
            .exceptionHandling().accessDeniedPage("/auths/access-denied")
            .and()
            .authorizeHttpRequests(authorize -> authorize             
                    .antMatchers("/orders/**").hasRole("ADMIN") 
                    .antMatchers("/members/my-page").hasRole("USER")
                    .antMatchers("/**").permitAll()
            );
        return http.build();
    }
```

2️⃣에서 구현된 filterChain()에서 .authorizeHttpRequests().anyRequest().permitAll(); 설정을 통해 로그인 인증에 성공할 경우, 모든 화면에 접근할 수 있도록 했던 부분을 **사용자의 Role 별로 request URI에 접근 권한이 부여**되도록 수정

1. **exceptionHandling().accessDeniedPage("/auths/access-denied")**를 통해 권한이 없는 사용자가 특정 request URI에 접근할 경우 발생하는 **403(Forbidden)** 에러를 처리하기 위한 페이지를 설정
    - **exceptionHandling ()** : Exception 처리를 수행
    - 리턴하는 **ExceptionHandlingConfigure 객체**를 통해 구체적인 Exception 처리가능
    - **accessDeniedPage()** 메서드는 403 에러 발생 시, 파라미터로 지정한 URL로 리다이렉트 되도록 해준다.
2. authorizeHttpRequests() 메서드에서 람다식으로 request URI에 대한 접근 권한을 부여
    - `antMatchers()` 메서드는 이름 그대로 **ant**라는 빌드 툴에서 사용되는 `Path Pattern`을 이용해서 매치되는 URL을 표현
    - `**`는 /orders로 시작하는 모든 하위 URL을 포함
    - `orders/*`라는 URL을 지정했다면 `/orders/1`과 같이 /orders의 하위 URL의 depth가 1인 URL만 포함
    - `antMatchers("/members/my-page").hasRole("USER")`은 `USER` Role을 부여받은 사용자만 `/members/my-page` URL에 접근할 수 있다.
    - `.antMatchers("/**").permitAll()`은 앞에서 지정한 URL 이외의 나머지 모든 URL은 Role에 상관없이 접근이 가능함을 의미
3. **antMatchers()를 이용한 접근 권한 부여 시, 주의 사항**
    - 만약에 authorizeHttpRequests() 메서드에서 `.antMatchers("/**").permitAll()` 이 제일 앞에 위치하게 되면 Role에 상관없이 모든 requestURL에 접근 허용하기 때문에 다음에 오는 접근 권한 조건은 제 기능을 하지 못하게 된다.
    - 항상 ⭐ **더 구체적인 URL 경로부터 접근 권한을 부여한 다음 덜 구체적인 URL 경로에 접근 권한을 부여하는 습관 들이기.**
    
    > 참고로 Ant는 Maven과 Gradle에 밀려서 거의 사용되지 않는 빌드 툴, but Ant에서 사용되는 Ant Pattern은 URL 경로 등을 지정하기 위한 Pattern 표현식으로 여러 오픈 소스에서 사용되고 있다.
    Maven도 xml을 사용해야해서 gradle로 많이 넘어가는 추세
    > 

### 5️⃣ 관리자 권한을 가진 사용자 추가

```java
...
@Configuration
public class SecurityConfiguration {
    ...
    ...
    @Bean
    public InMemoryUserDetailsManager userDetailsService() {
        UserDetails user =
                User.withDefaultPasswordEncoder()
                        .username("kevin@gmail.com")
                        .password("1111")
                        .roles("USER")
                        .build();
                        
        UserDetails admin =
                User.withDefaultPasswordEncoder()
                        .username("admin@gmail.com")
                        .password("2222")
                        .roles("ADMIN")
                        .build();

        return new InMemoryUserDetailsManager(user, admin);
    }
}
```

### 6️⃣ 로그인 한 사용자 아이디 표시 및 사용자 로그아웃.

로그인 한 사용자 표시 & 로그인 한 사용자 로그아웃 하기 & 마이페이지 링크는 로그인 한 사용자에게만 보이게 하기

1. header.html 수정 → 로그아웃 및 권한 별 메뉴표시하기
    
    ```java
    <html xmlns:th="<http://www.thymeleaf.org>"
          xmlns:sec="<http://www.thymeleaf.org/thymeleaf-extras-springsecurity5>"> 
          <!-- (1) -->
        <body>
            <div align="right" th:fragment="header">
                <a href="/members/register" class="text-decoration-none">회원가입</a> |
                <span sec:authorize="isAuthenticated()"> <!-- (2) -->
                    <span sec:authorize="hasRole('USER')">  <!-- (3) -->
                        <a href="/members/my-page" class="text-decoration-none">마이페이지</a> |
                    </span>
                    <a href="/logout" class="text-decoration-none">로그아웃</a>  <!-- (4) -->
                    <span th:text="${#authentication.name}">홍길동</span>님  <!-- (5) -->
                </span>
    
                <span sec:authorize="!isAuthenticated()"> <!-- (6) -->
                    <a href="/auths/login-form" class="text-decoration-none">로그인</a>
                </span>
            </div>
        </body>
    </html>
    
    ```
    
    - 타임리프 기반의 HTML 템플릿에서 사용자의 인증 정보나 권한 정보를 이용해 어떤 로직을 처리하기 위해서는 먼저 (1)과 같이 `sec` 태그를 사용하기 위한 XML 네임스페이스를 지정, 지정하지 않아도 동작하지만 태그에 에러 표시 남.
    - **(2) :** <span> 태그 내부에서 `sec:authorize="isAuthenticated()"`를 지정하면 현재 페이지에 접근한 사용자가 인증에 성공한 사용자인지를 체크
        - ⇒ `isAuthenticated()`의 값이 `true`이면  <span> 태그 하위에 포함된 콘텐츠를 화면에 표시
    - **(3)** : 인증에 성공한 사용자라면 마이페이지는 USER Role을 가진 사용자에게만 표시 되도록 한다.
    - **(4)** : (2)에서 로그인에 성공한 사용자는 [로그인] 메뉴 대신 [로그아웃]이 표시된다.
        - `href="/logout"`에서 “/logout” URL은 SecutiryConfiguration 클래스에서 설정한 값과 같아야 한다.
    - **(5) :** `th:text="${#authentication.name}"`를 통해 로그인 사용자의 username을 표시 → 로그인 한 사용자는 username이 표시되고
    - **(6) :** sec:authorize="!isAuthenticated()"를 통해 로그인 한 사용자가 아니라면 [로그인] 버튼이 표시되도록 한다.
        - sec 태그 사용시  build.gradle에서 의존 라이브러리 추가 해야함
        - implementation 'org.thymeleaf.extras:thymeleaf-extras-springsecurity5'
2. **SecurityConfiguration  클래스에 로그아웃 설정 추가**
    - 로그아웃을 눌렀을 때는 스프링 은 로그아웃 url을 설정 시 기본적으로 권한이 사라지게 설정 되어 있음. → 로그인 페이지로 이동하게 되어있음,
    - 우리가 로그아웃을 설정하면  성공했을 때 루트로 이동하게 코드 추가.
        
        ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2013.png)
        
    - logout() 메서드는 로그아웃 설정을 위한 `LogoutConfigurer`를 리턴
    - logoutUrl("/logout")을 통해 사용자가 로그아웃을 수행하기 위한 request URL을 지정 ⇒ ⭐ 여기서 설정한 URL은 header.html의 로그아웃 메뉴에 지정한 `href=”/logout”`과 동일해야 한다.
    - .logoutSuccessUrl("/") : 로그아웃을 성공적으로 수행한 이후 리다이렉트 할 URL을 지정, 여기서는 메인화면으로 리다이렉트 하도록 지정.
    - 로그아웃 클릭 시 헤더가 바뀌게 됨.
        
        ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2014.png)
        

# 회원가입 기능 구현

여기까지 Security filterChain으로 인증인가를 구현  → 이제  인메모리DB로 변경

![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2015.png)

이 UserDetails객체가 새로 생성되어야함 

아직DB는 사용하지 않을 것이기 때문에 InMemoryUserDetailsManager로 반환할 예정

### 회원 가입 폼을 통한 InMemory User 등록

회원 가입 폼을 통해 InMemory User를 등록하기 위한 작업 순서는 다음과 같습니다.

- PasswordEncoder Bean 등록
- MemberService Bean 등록을 위한 JavaConfiguration 구성
- InMemoryMemberService 클래스 구현

### 1️⃣ **PasswordEncoder Bean 등록**

PasswordEncoder는 Spring Security에서 제공하는 패스워드 암호화 기능을 제공하는 컴포넌트이다.

> PasswordEncoder는 다양한 암호화 방식을 제공하며, Spring Security에서 지원하는 PasswordEncoder의 디폴트 암호화 알고리즘은 bcrypt이다.
> 

![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2016.png)

- 회원 가입 폼을 통해 애플리케이션에 전달되는 패스워드는 암호화되지 않은 플레인 텍스트(Plain Text) →암호화하기위해 passwordEncorder사용
- **회원 가입 폼에서 전달받은 패스워드는 InMemory User로 등록하기 전에 암호화되어야 한다.**

**SecurityConfiguration 클래스에서 PasswordEncoder를 Bean으로 등록**

```java
@Configuration
public class SecurityConfiguration {
...

@Bean
public PasswordEncoder passwordEncoder(){
    return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }
}
```

`PasswordEncoderFactories.createDelegatingPasswordEncoder();`를 통해 `DelegatingPasswordEncoder`를 먼저 생성하는데, 이 `DelegatingPasswordEncoder`가 실질적으로 **PasswordEncoder** 구현 객체를 생성해 준다.

> **참고)** 개발환경에서만 인메모리 DB 사용할 거고 @configuration으로 빈객체를 만드는 것임. @Configuration+@bean을 사용하지않고 @Component 사용 해도 됨.
> 

### 2️⃣ MemberService Bean 등록을 위한 JavaConfiguration 구성

1. MemberSercice
    
    회원 가입 폼에서 전달받은 정보를 이용해 새로운 사용자를 추가하는 기능만 있으면 되므로 `createMember()` 하나만 구현하는 구현체가 있으면 된다.
    
    ```java
    package com.springboot.member;
    
    public interface MemberService {
        Member createMember(Member member);
    }
    
    ```
    
2. **InMemoryMemberService** → MemberService 인터페이스를 구현하는 구현 클래스
    
    ```java
    package com.springboot.member;
    
    public class InMemoryMemberService implements MemberService {
        public Member createMember(Member member) {
    
            return null; // 뒤에서 구현 할 예정이다.
        }
    }
    
    ```
    
3. **DBMemberService 클래스 → 데이터베이스에 User를 등록**하기 위한 MemberService 인터페이스의 구현 클래스
    
    ```java
    package com.springboot.member;
    
    import org.springframework.transaction.annotation.Transactional;
    
    @Transactional
    public class DBMemberService implements MemberService {
        public Member createMember(Member member) {
             return null; // InMemory User 등록이 끝난 다음 학습내용,  이어서 바로 구현
        }
    }
    
    ```
    

1. **JavaConfiguration 구성 :**  MemberService Bean 등록을 위한 JavaConfiguration 구성
    
    ```java
    package com.springboot.config;
    
    import com.springboot.member.InMemoryMemberService;
    import com.springboot.member.MemberService;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import org.springframework.security.provisioning.UserDetailsManager;
    
    @Configuration
    public class JavaConfiguration {
        
        @Bean
        public MemberService inMemoryMemberService(UserDetailsManager userDetailsManager,
                                                   PasswordEncoder passwordEncoder) {
            return new InMemoryMemberService(userDetailsManager, passwordEncoder);
        }
    }
    
    ```
    
    - MemberService 인터페이스의 구현 클래스인 InMemoryMemberService를 Spring Bean으로 등록
    - **데이터베이스 연동 없이 메모리에 Spring Security의 User를 등록**해야 하므로 `UserDetailsManager` 객체가 필요
    - User 등록 시, **패스워드를 암호화한 후에 등록**해야 하므로 Spring Security에서 제공하는 `PasswordEncoder` 객체가 필요
    - 두 객체를 InMemoryMemberService 객체 생성 시, DI 해 주어야 한다.
    

### **3️⃣ InMemoryMemberService 구현**

```java
package com.springboot.member;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.UserDetailsManager;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

//(1) @Service 애너테이션은 여기에 달지 않는다, 중복안됨. 바로 위 JavaConfiguration에서 반환되는 
// InMemoryMemberService가 빈으로 등록되었기 때문.
public class InMemoryMemberService implements MemberService {
     //(2)
    private final UserDetailsManager userDetailsManager;
  
    private final PasswordEncoder passwordEncoder;

    public InMemoryMemberService(UserDetailsManager userDetailsManager, PasswordEncoder passwordEncoder) {
        this.userDetailsManager = userDetailsManager;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    public Member createMember(Member member) {
		  //(3)
        List<GrantedAuthority> authorities = createAuthories(Member.MemberRole.ROLE_USER.name());
        //일반적인 회원가입은 user로 권한 설정해줌
        //파라미터로 들어온 member는 dto에서 변환 된 것 , 비밀번호는 아직 평문이다. 암호화해야 함.
        //List로 관리 함.
        String encryptedPassword = passwordEncoder.encode(member.getPassword());
       
       //(4)
        UserDetails userDetails = new User(member.getEmail(), encryptedPassword, authorities);
                                    //우리가 만든 유저 아님.

        userDetailsManager.createUser(userDetails); 
		        //UserDetailsManager의 createUser() 메서드를 이용해서 User를 등록
        return member;
    }

		//(5) 
    private List<GrantedAuthority> createAuthories(String ...roles){
        return Arrays.stream(roles)
                .map(role-> new SimpleGrantedAuthority(role))
                .collect(Collectors.toList());

        //권한을 리스르토 받는 이유
        //한 사용자가 여러 개의 권한을 가질 수 있기 때문
        //예를 들어, 한 사용자가 ROLE_USER와 ROLE_ADMIN 권한을 동시에 가질 수 있다.
        // 따라서 권한을 리스트로 관리하여 유연하게 여러 권한을 부여할 수 있다.

    }
}

```

- (1) 에서 @Service 애너테이션은  달지 않는다,  빈은 중복안됨. 바로 위 JavaConfiguration에서 반환되는InMemoryMemberService가 빈으로 등록되었기 때문.
- (2)  에서  `UserDetailsManager`와 `PasswordEncoder`를 DI 받는다.
    - UserDetailsManager는 Spring Security의 User를 관리하는 관리자 역할을 한다..
    - SecurityConfiguration에서 빈 설정을 한 이유는 여기서 주입하려고,  ⇒ PSA (Policy Service Abstraction) 원칙에 따라 추상 메서드를 사용하면 메서드 이름을 바꾸지 않고도 일관된 방식으로 주입 가능
    - UserDetailsManager 인터페이스의 하위 타입은`InMemoryUserDetailsManager`라는 사실 기억하기.
- (3) : Spring Security에서 User를 등록하기 위해서는 해당 User의 권한(Authority)을 지정해 주어야 한다.
    - `createAuthorities(Member.MemberRole.ROLE_USER.name());`를 이용해 User의 권한 목록을 `List<GrantedAuthority>`로 생성
    - Member 클래스에는 `MemberRole`이라는 enum이 정의되어있다.
        
        ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2017.png)
        
        ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2018.png)
        
    - ⭐ Spring Security에서는 `SimpleGrantedAuthority`를 사용해 Role 베이스 형태의 권한을 지정할 때 `‘ROLE_’ + 권한 명` 형태로 지정해 주어야 한다. 그렇지 않을 경우 적절한 권한 매핑이 이루어지지 않는다는 사실 기억하기
- (4)에서는 Spring Security User로 등록하기 위해 `UserDetails`를 생성한다.
    
    ⭐ Spring Security에서는 Spring Security에서 관리하는 User 정보를 `UserDetails`로 관리한다는 것 꼭 기억하기
    
- (5) 의 createAuthories 메서드 : Stream API를 이용해 생성자 파라미터로 해당 User의 Role을 전달하면서 `SimpleGrantedAuthority` 객체를 생성한 후, `List<SimpleGrantedAuthority>` 형태로 리턴

## 데이터 베이스 연동을 통한 로그인 인증

테스트 환경이므로 DB도 인메모리로 사용할 예정 

### Custom UserDetailsService를 사용하는 방법

Spring Security에서는 User의 인증 정보를 테이블에 저장하고, 테이블에 저장된 인증 정보를 이용해 인증 프로세스를 진행할 수 있는 몇 가지 방법이 있고 그 중 하나가 Custom UserDetailsService를 사용하는 것.

### 1️⃣ **SecurityConfiguration의 설정 변경 및 추가**

1. H2는 데이터베이스 접속을 하기 위해 뷰단에서 SameOringin설정 해야 볼 수 있음.
    
    ```java
    @Configuration
    public class SecurityConfiguration {
     @Bean
     public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    
            http. headers().frameOptions().sameOrigin()
                    //같은 페이지일 경우 페이지렌더링을 허용하겠다 
                    // 실무에서도 아마 안쓸 확률이 높음.
                .and()
                .csrf().disable()
                .formLogin()
                ...
                ...
                return http.build();
                
    ```
    

1.  데이터베이스에 저장되어 있는 인증 정보를 사용할 것이라서 InMemory User를 위한 설정들은 더 이상 필요 없으므로 제거,  아래 코드는 다 제거하면 된다.
    
    ```java
        @Bean //스프링 컨테이너의 도움을 받기 위함 => 사실은 javaconfiguration에서 주입하기 위함
        public UserDetailsManager userDetailService(){
    //        UserDetails user =
    //                User.withDefaultPasswordEncoder()
    //                        .username("jerry@gmail.com") 
    //                        .password("wpfl")
    //                        .roles("USER") 
    //                        .build(); 
            UserDetails admin =
                    User.withDefaultPasswordEncoder()
                            .username("admin@gmail.com") //일반적으로 통용되는 아이디의 개념.
                            .password("ehowl")
                            .roles("ADMIN") //인가 : 권한을 뭘 줄 것인지?
                            .build();
            return new InMemoryUserDetailsManager(admin);
       
    
        }
    ```
    

인메모리서비스 수정

### **2️⃣ JavaConfiguration의 Bean 등록 변경**

 데이터베이스에 User의 정보를 저장하기 위해 MemberService 인터페이스의 구현 클래스를 inMemoryMemberService에서 DBMemberService로 변경

```java
...
@Configuration
public class JavaConfiguration {
    @Bean
    public MemberService inMemoryMemberService(UserDetailsManager userDetailsManager,
                                               PasswordEncoder passwordEncoder) {
        return new InMemoryMemberService(userDetailsManager, passwordEncoder);
    }
}

```

⬇️⬇️

```java
@Configuration
public class JavaConfiguration {
    // (1)
    @Bean
    public MemberService dbMemberService(MemberRepository memberRepository,
                                         PasswordEncoder passwordEncoder) {
        return new DBMemberService(memberRepository, passwordEncoder); (1-1)
    }
}
```

DBMemberService는 내부에서 데이터를 데이터베이스에 저장하고, 패스워드를 암호화해야 하므로  `MemberRepository`와 `PasswordEncoder` 객체를 DI 해준다.

### 3️⃣ **DBMemberService 구현**

```java
@Transactional
public class DBMemberService implements MemberService {
    private final MemberRepository memberRepository;
    private final PasswordEncoder passwordEncoder;

    public DBMemberService(MemberRepository memberRepository,
                             PasswordEncoder passwordEncoder) {
        this.memberRepository = memberRepository;
        this.passwordEncoder = passwordEncoder;
    }

    public Member createMember(Member member) {
        verifyExistsEmail(member.getEmail());
        String encryptedPassword = passwordEncoder.encode(member.getPassword());  // (1)
        member.setPassword(encryptedPassword);    // (2)

        Member savedMember = memberRepository.save(member);

        System.out.println("# Create Member in DB");
        return savedMember;
    }

    ...
    ...
}

```

- (1)에서 PasswordEncoder를 이용해 패스워드를 암호화한다.
- (2)에서 암호화된 패스워드를 password 필드에 다시 할당한다.

### **4️⃣ Custom UserDetailsService 구현  - V1**

**데이터베이스에서 조회한 User의 인증 정보를 기반으로 인증을 처리**

> **⭐ UserDetailsService**
> 
> 
> Spring Security에서 제공하는 컴포넌트 중 하나인 `UserDetailsService`는 User 정보를 로드(load)하는 핵심 인터페이스
> 
> 여기서 로드(load)의 의미는 **인증에 필요한 User 정보를 어딘가에서 가지고 온다**는 의미이며, 여기서 말하는 ‘**`어딘가`**’는 메모리가 될 수도 있고, DB 등의 영구 저장소가 될 수도 있습니다.
> 
> 우리가 InMemory User를 등록하는 데 사용했던 InMemoryUserDetailsManager는 UserDetailsManager 인터페이스의 구현체이고, UserDetailsManager는 UserDetailsService를 상속하는 확장 인터페이스
> 
1. **HelloUserDetailsService**
    
    데이터베이스의 인증 정보로 인증을 처리하는 Custom UserDetailsService
    
    ```java
    @Component
    public class HelloUserDetailsServiceV1 implements UserDetailsService {   // (1)
        private final MemberRepository memberRepository;
        private final HelloAuthorityUtils authorityUtils;
    
        // (2)
        public HelloUserDetailsServiceV1(MemberRepository memberRepository, HelloAuthorityUtils authorityUtils) {
            this.memberRepository = memberRepository;
            this.authorityUtils = authorityUtils;
        }
    
        // (3)
        @Override
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            Optional<Member> optionalMember = memberRepository.findByEmail(username);
            Member findMember = optionalMember.orElseThrow(() -> new BusinessLogicException(ExceptionCode.MEMBER_NOT_FOUND));
    
            // (4)
            Collection<? extends GrantedAuthority> authorities = authorityUtils.createAuthorities(findMember.getEmail());
    
            // (5) 개선하면 좋은 포인트
            return new User(findMember.getEmail(), findMember.getPassword(), authorities);
        }
    }
    
    ```
    
    - (1) :  `UserDetailsService` **인터페이스를 구현한다.**
    - (2) : 데이터베이스에서 User를 조회하고, 조회한 User의 권한(Role) 정보를 생성하기 위해 `MemberRepository`와 `HelloAuthorityUtils` 클래스를 DI 받는다.
    - `UserDetailsService` 인터페이스를 implements 하는 구현 클래스는 (3)과 같이 `loadUserByUsername(String username)`이라는 추상 메서드를 구현해야 한다.
    - `HelloAuthorityUtils`를 이용해 데이터베이스에서 조회한 회원의 이메일 정보를 이용해 Role 기반의 권한 정보(`GrantedAuthority`) 컬렉션을 생성한다.
    - (4)에서 생성한 권한 정보를 Spring Security에서는 아직 알지 못하기 때문에 Spring Security에 이 정보들을 제공해 주어야 하며, (5)에서는 `UserDetails` 인터페이스의 구현체인 `User` 클래스의 객체를 통해 제공
    - (5)와 같이 데이터베이스에서 조회한 User 클래스의 객체를 리턴하면 Spring Security가 이 정보를 이용해 인증 절차를 수행한다.
    
    ⭐ **즉, 데이터베이스에서 User의 인증 정보만 Spring Security에 넘겨주고, 인증 처리는 Spring Security가 대신해 준다**
    
    > ⭐ UserDetails
    > 
    > 
    > `UserDetails`는 UserDetailsService에 의해 로드(load)되어 인증을 위해 사용되는 핵심 User 정보를 표현하는 인터페이스이다.
    > 
    > `UserDetails` 인터페이스의 구현체는 Spring Security에서 보안 정보 제공을 목적으로 직접 사용되지는 않고, `Authentication` **객체로 캡슐화되어 제공된다.**
    > 

1.  **HelloAuthorityUtils**
    
    ```java
    package com.springboot.auth.utils;
    
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.security.core.GrantedAuthority;
    import org.springframework.security.core.authority.AuthorityUtils;
    import org.springframework.stereotype.Component;
    import java.util.List;
    
    @Component
    public class HelloAuthorityUtils {
        // (1)
        @Value("${mail.address.admin}")
        private String adminMailAddress;
    
        // (2)
        private final List<GrantedAuthority> ADMIN_ROLES = AuthorityUtils.createAuthorityList("ROLE_ADMIN", "ROLE_USER");
    
        // (3)
        private final List<GrantedAuthority> USER_ROLES = AuthorityUtils.createAuthorityList("ROLE_USER");
    
        public List<GrantedAuthority> createAuthorities(String email) {
            // (4)
            if (email.equals(adminMailAddress)) {
                return ADMIN_ROLES;
            }
            return USER_ROLES;
        }
    }
    
    ```
    
    - (1)은 application.yml에 추가한 프로퍼티를 가져오는 표현식
        
        ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2019.png)
        
        - 이걸 넣는다고 자동으로 관리자권한의 메일이 생성되지 않는다
        - 이걸 설정하면 (4)에서 가입한 사람의 이메일을 검증한다. ⇒  admin으로 넣어둔 이메일과 동일한지, 만약 동일하다면 ADMIN_ROLES를 부여 , 아니라면 USER_ROLES → 인가는 로그인 하고 나서 인가가 이루어짐.,
            
            > ⭐ 실무에서는 당연히 회원 가입 시, 아무런 인증 장치도 없이 이메일 주소만 입력해서 관리자 권한을 부여하지는 않는다.
            > 
            > 
            > 관리자 권한은 아무리 강조해도 지나치지 않을 정도로 중요!
            > 
            > **관리자로서 등록하기 위한 추가적인 인증 절차**가 있을 것
            > 
    - (4)에서 `List<GrantedAuthority>` 를 리턴하면 회원에게 인가가 부여 됨.
        
        ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2020.png)
        

1. **H2 웹 콘솔에서 등록한 회원 정보 확인 및 로그인 인증 테스트**
    - 회원가입 및 로그인 잘 됨.
        
        ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2021.png)
        
    - h2 console 확인하면 아래와 같이 정보 들어옴
        
        ![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2022.png)
        
        PASSWORD 열을 보면 회원 가입 메뉴에서 입력했던 **패스워드 정보가 암호화 되어있다**
        

**`HelloUserDetailsServiceV2`생성** 

V1에 있던 @Component 는 삭제해야 함. 하나만 있어야 한다.

 UserDetails의 구현 클래스인 User의 객체를 직접적으로 생성해서 리턴하는 부분을 개선할 것.

```java
package com.springboot.auth;

import com.springboot.exception.BusinessLogicException;
import com.springboot.exception.ExceptionCode;
import com.springboot.member.Member;
import com.springboot.member.MemberRepository;
import com.springboot.utils.HelloAuthorityUtils;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.List;
import java.util.Optional;

@Component
public class HelloUserDetailsServiceV2 implements UserDetailsService {
    private final MemberRepository memberRepository;
    private final HelloAuthorityUtils helloAuthorityUtils;

    public HelloUserDetailsServiceV2(MemberRepository memberRepository, HelloAuthorityUtils helloAuthorityUtils) {
        this.memberRepository = memberRepository;
        this.helloAuthorityUtils = helloAuthorityUtils;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //UserDetailsService를 사용하려면 필수로 있어야 하는 메서드
        Optional<Member> optionalMember = memberRepository.findByEmail(username);
        Member findMember = optionalMember.orElseThrow(()-> new BusinessLogicException(ExceptionCode.MEMBER_NOT_FOUND));

        //List<GrantedAuthority> authorities=helloAuthorityUtils.createAuthorities(findMember.getEmail());
        //return new User(findMember.getEmail(), findMember.getPassword(), authorities);
				return new HelloUserDetails(findMember);
    }
    
    
    //------------------------추가한 코드 --------------------------------------

    //이너 클래스 생성 , 인터페이스 구현하면서 엔티티를 상속. 상속이 먼저와야 한다.
    private final class HelloUserDetails  extends Member implements UserDetails{

        //아래 클래스는 멤버를 상속하기 때문에 필드에 없어도 다 가지고 있다 (Member 가 super클래스에 해당)
        // (private로 선언된 것을 제외하고, getter setter는 다 public 이기 때문에 가져오는 것이 가능)
        HelloUserDetails(Member member){
            setMemberId(member.getMemberId());
            setEmail(member.getEmail());
            setFullName(member.getFullName());
            setPassword(member.getPassword());
        }

        @Override
        public Collection<? extends GrantedAuthority> getAuthorities() { //인가정보를 만들어 주어야 함.
            return helloAuthorityUtils.createAuthorities(this.getEmail());//HelloUserDetails의 이메일을 가져오는 것-> this
        }

        @Override
        public String getUsername() {
            return this.getEmail();
        }

//크게 중요하지 않아서 모두 true로 변경
        @Override
        public boolean isAccountNonExpired() {
            return true;
        }

        @Override
        public boolean isAccountNonLocked() {
            return true;
        }

        @Override
        public boolean isCredentialsNonExpired() {
            return true;
        }

        @Override
        public boolean isEnabled() {
            return true;
        }
    }
}

```

- 기존에는 loadUserByUsername() 메서드의 리턴 값으로 new User(findMember.getEmail(), findMember.getPassword(), authorities);을 리턴했지만 개선된 코드에서는 (1)과 같이 new HelloUserDetails(findMember);라는 Custom UserDetails 클래스의 생성자로 findMember를 전달
- (2)의 HelloUserDetails 클래스는 UserDetails 인터페이스를 구현하고 있고 또한 Member 엔티티 클래스를 상속하고 있다.
    - loadUserByUsername() 메서드 내부에서 User의 권한 정보를 생성하는 코드도 안으로 들어감. ⇒ Collection<? extends GrantedAuthority> authorities = authorityUtils.createAuthorities(findMember);도 HelloUserDetails 클래스 내부로 이동

💡 이렇게 구성하면 **데이터베이스에서 조회한 회원 정보를 Spring Security의 User 정보로 변환하는 과정**과 **User의 권한 정보를 생성하는 과정**을 **캡슐화**할 수 있습니다.

💡 또한 `HelloUserDetails` 클래스는 `Member` 엔티티 클래스를 상속하고 있으므로 HelloUserDetails를 리턴 받아 사용하는 측에서는 두 개 클래스의 객체를 모두 다 손쉽게 캐스팅해서 사용 가능하다는 장점

2-3)에서는 `HelloAuthorityUtils`의 `createAuthorities()` 메서드를 이용해 User의 권한 정보를 생성하고 있습니다.

이 코드는 기존에는 loadUserByUsername() 메서드 내부에 있었지만 지금은 `HelloUserDetails` 클래스 내부에서 사용되도록 캡슐화되었습니다

- (2-4)에서는 Spring Security에서 인식할 수 있는 username을 Member 클래스의 email 주소로 채우고 있습니다. `getUsername()`의 **리턴 값은 null일 수 없습니다.**
- 기타 UserDetails 인터페이스의 추상 메서드를 구현한 부분은 지금은 크게 중요하지 않은 부분이므로 모두 `true`값을 리턴하고 있습니다.

아래에 이너클래스 생성. 

![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2023.png)

![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2024.png)

권한관련 정보는 실무에서 실제로 테이블을 따로 만들어서 관리한다.

(기본키 1번은 admin 나머지는 user) 

하나의 멤버는 하나의 권한? no . 하나의 권한은 하나의 멤버만? no ⇒ 다대다

그러나 일대다로 구현할 예정임, member는 스프시큐리티가 관리하기때문에 멤버에게서만 관계구현 하면 됨.

```java
    @ElementCollection(fetch = FetchType.EAGER)
    //권한 관련 테이블에 설정 -> 애너테이션만 달아도 자동으로 테이블이 생성됨.
```

![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2025.png)

![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2026.png)

![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2027.png)

setRoles는 문자열이고 spring security는 인지를 못함. 실제 반환해주어야 함 리스트로

![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2028.png)

구현체 사용할 것.

![Untitled](240704%203e0dcfc9306e4c29a3694fba1c3e890b/Untitled%2029.png)

4-31 `createRoles()` 메서드가 추가된 `HelloAuthorityUtils` 클래스의 코드

```java
package com.springboot.utils;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.AuthorityUtils;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

@Component
public class HelloAuthorityUtils {
    @Value("${mail.address.admin}")
    private String adminMailAddress;
    private final List<GrantedAuthority> ADMIN_ROLES= AuthorityUtils.createAuthorityList("ROLE_ADMIN", "ROLE_USER");
    private final List<GrantedAuthority> USER_ROLES =AuthorityUtils.createAuthorityList("ROLE_USER");
    private final List<String> ADMIN_ROLES_STRING = List.of("ADMIN", "USER");
    private final List<String> USER_ROLES_STRING = List.of("USER");

    //메모리의 role을 기반으로 권한 정보 생성
    public List<GrantedAuthority> createAuthorities(String email){
        if(email.equals(adminMailAddress)){
            return ADMIN_ROLES;
        }else {
            return USER_ROLES;
        }
    }

    //DB에 저장된 Rolse를 기반으로 권한 정보 생성
    public List<GrantedAuthority>createAuthorities(List<String> roles){
        List<GrantedAuthority> authorities = roles.stream().map(role-> new SimpleGrantedAuthority("ROLE_"+role))
                .collect(Collectors.toList());
        return authorities;
    }

    //DB에 저장하기 위한 형태의 roles를 반환하는 메서드
    public List<String>createRoles(String email) {
        if (email.equals(adminMailAddress)) {
            return ADMIN_ROLES_STRING;
        } else {
            return USER_ROLES_STRING;
        }
    }
}

```

 UserDetails의 구현 클래스인 User의 객체를 직접적으로 생성해서 리턴하는 부분