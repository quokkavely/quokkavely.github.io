---
layout : single
title : "[SQLD] 기출1회 오답정리"
categories: Database
tag : [SQLD, SQL]
author_profile: true
---

📌 개인적인 공간으로 공부를 기록하고 복습하기 위해 사용하는 블로그입니다. <br>
정확하지 않은 정보가 있을 수 있으니 참고바랍니다 :😸 <br>
[틀린 내용은 댓글로 남겨주시면 복받으실거에요]  
{: .notice--primary}

## 오답노트

### 242p 18번

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/f7511b05-f7b2-446f-8b14-0575185a1028/a443de4c-293c-49ef-a7ea-92bdc4eb5929/image.png)

문제가 진짜 불친절한데 EMPNO  MGRNO 가 뭔지 나는 모르는데 어떻게 풀라는건지ㅠㅠ

- **선택한 답**: 1번
- **오답 이유**:1번 아니면 2번이라고 생각했는데 알고보니 EMPNO 가  직원번호, MGRNO가 상사번호이며`MGRNO`가 `EMPNO`에 대응될 때 해당 상사의 이름을 찾는 것이 었음.
- **정답:** `A.EMPNO = B.MGRNO` 조건으로 직원 `B`의 `MGRNO`가 상사 `A`의 `EMPNO`와 일치하는 경우를 찾음.`B.EMPNO`, `B.NAME`은 직원 정보, `A.NAME`은 상사 이름을 가져와 결과와 일치하는 구조를 만들어내면 된다. ⇒ 이에 해당하는 답은 1번

### 복원기출 1회 13번

![KakaoTalk_20241108_003149223_12.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/f7511b05-f7b2-446f-8b14-0575185a1028/3a560172-40ec-49fa-9fb0-dd85876d7e8d/KakaoTalk_20241108_003149223_12.jpg)

- 선택한 답 : 1
- 정답 : 3 `SUBSTR('DATABASE', 8, -2)`에서 길이가 음수인 경우는 유효하지 않은 구문으로, 오류가 발생한다. 나머지 옵션(1, 2, 4)은 정상적으로 `"SE"` 결과를 반환한다.

### 복원기출 1회 17번

![KakaoTalk_20241108_003149223_11.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/f7511b05-f7b2-446f-8b14-0575185a1028/90492260-5577-4f39-ac0e-08ce61f09b0e/KakaoTalk_20241108_003149223_11.jpg)

- 선택한 답 : 2번
- 정답 : 3번
- **1번: "WINDOW FUNCTION을 GROUP BY 절과 함께 사용하였으므로 위의 SQL은 오류가 발생한다."**
    - 윈도우 함수는 집계 함수와 함께 사용될 수 있으며, `GROUP BY`와 함께 사용할 때도 오류가 발생하지 않는다.
- **2번: "WINDOW FUNCTION의 ORDER BY 절에 AVG 집계함수를 사용하였으므로 위의 SQL은 오류가 발생한다."**
    - 윈도우 함수 내 `ORDER BY` 절에서 집계 함수(`AVG`)를 사용하는 것은 가능하다.
- **3번: "유사개수 칼럼은 상품분류코드별 평균상품가격을 서로 비교하여 -10000 ~ +10000 사이에 존재하는 상품분류코드의 개수를 구한 것이다."**
    - `상품분류코드별 평균상품가격`을 기준으로, ±10000 범위 내에 해당하는 상품분류코드의 개수를 구한 것이므로 이 설명이 맞다.
- **4번: "유사개수 칼럼은 상품 전체의 평균상품가격을 서로 비교하여 -10000 ~ +10000 사이에 존재하는 상품의 개수를 구한 것이다."**
    - 상품 전체의 평균 상품 가격을 기준으로 비교하는 것이 아니라, 각 `상품분류코드별 평균 상품 가격`을 기준으로 ±10000 범위 내에 존재하는 개수를 구한 것이다.

### 복원기출 1회 21번

![KakaoTalk_20241108_003149223_10.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/f7511b05-f7b2-446f-8b14-0575185a1028/c6c50665-1bb9-4a10-bc50-1ce3f73b9b99/KakaoTalk_20241108_003149223_10.jpg)

- 각 함수마다 `OVER` 절을 통해 특정 범위를 설정해서 값을 계산
- **MAX(COL1) 에서 `BETWEEN UNBOUNDED PRECEDING AND 2 FOLLOWING`**
    - **UNBOUNDED PRECEDING**: 현재 행에서 시작하여 윈도우의 첫 번째 행(맨 처음 행)까지 포함.
    - **2 FOLLOWING**: 현재 행부터 **두 행 이후**까지 포함.
    - 현재 행에서 시작하여 윈도우의 첫 번째 행부터 현재 행 기준으로 두 행 뒤까지의 COL1 값 중 최대값을 반환
- **SUM(COL2) 에서`BETWEEN 1 PRECEDING AND CURRENT ROW`**
    - **1 PRECEDING**: 현재 행의 바로 이전 행을 포함.
    - **CURRENT ROW**: 현재 행을 포함.
    - 현재 행과 바로 이전 행의 `COL2` 값을 더한 값을 반환한다. 즉, 현재 행 기준으로 두 행의 합계를 계산하는 것이다.
- FIRST_VALUE(COL1)에서  **`BETWEEN 200 PRECEDING AND 200 FOLLOWING`**
    - 200 PRECEDING: 현재 행의 COL1 값에서 **200 작은 값**까지 포함.
    - 200 FOLLOWING: 현재 행의 COL1 값에서 **200 큰 값**까지 포함.
    - 현재 행을 기준으로 COL1 값이 ±200 범위 내에 있는 값 중 가장 첫 번째 값을 반환

결론

- **`MAX(COL1)`:** 현재 행을 기준으로, 첫 번째 행부터 두 행 뒤까지의 COL1 중 최대값.
- **`SUM(COL2)`:** 현재 행과 바로 이전 행의 COL2 값 합계.
- **`FIRST_VALUE(COL1)`:** 현재 행을 기준으로 COL1이 ±200 범위에 있는 값 중 첫 번째 값.

> **기억하기**
> 
> - **`ROWS`**: 물리적인 행 개수를 기준으로 범위를 지정.
> - **`RANGE`**: 값의 범위를 기준으로 범위를 지정.
> - **`PRECEDING`**: 현재 행 이전의 행이나 값보다 작은 범위.
> - **`FOLLOWING`**: 현재 행 이후의 행이나 값보다 큰 범위.
> - **`CURRENT ROW`**: 현재 행 그 자체를 포함하는 범위.

### 복원기출 1회 37번

![KakaoTalk_20241108_003149223_05.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/f7511b05-f7b2-446f-8b14-0575185a1028/d316a645-306d-406d-85b1-1f46905e9876/KakaoTalk_20241108_003149223_05.jpg)

- **해시조인이란?**
    - 해시 조인은 데이터베이스에서 두 테이블을 조인할 때 주로 사용하는 방식 중 하나로, 특히 **큰 테이블을 조인할 때** 성능이 좋은 방법이다.
    - 해시 조인 과정
        1. 작은 테이블을 먼저 읽어서 해시 테이블(Hash Table)을 만들고, 이 해시 테이블을 메모리의*해시 영역(Hash Area)에 저장.
        2. 큰 테이블의 행을 하나씩 읽으면서 해시 테이블에 매핑하여 매칭되는 행을 찾는 방식으로 조인 수행.
- 선택한 답 : 2번
- 정답: 3번
    - **1번**: 해시 조인은 **동등 조인(EQUI JOIN)**, 즉 "=" 연산으로 매칭할 때 가장 효과적이다. 범위 검색(>, < 등)에는 적합하지 않다.
    - **2번**: 해시 조인은 일반적으로 **작은 테이블을 먼저 읽어서 해시 테이블을 만들고** 이를 메모리에 저장한다. 큰 테이블을 해시 테이블로 만들면 메모리 사용량이 과다해지고 성능이 저하될 수 있지만 여기서 말하는 "과다한 Sort"는 해시 조인과 직접적인 연관이 없다.
    - **3번**:  해시 조인은 일반적으로 **대량의 데이터를 처리**하는 데 유리하며, 온라인 트랜잭션 처리(OLTP)보다는 온라인 분석 처리(OLAP)에 더 적합하다.
    - **4번**:  해시 조인은 대용량 테이블을 조인할 때 **성능을 최적화**하는 데 효과적이다. 특히 인덱스를 사용하기 어려운 경우에 유용하다.

### 복원기출 1회 44번

![KakaoTalk_20241108_003149223_03.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/f7511b05-f7b2-446f-8b14-0575185a1028/c4cfc01e-d8c7-47fa-b5bf-7df725633971/KakaoTalk_20241108_003149223_03.jpg)

- 선택한 답: 3번
- 정답 : 2번
    - **1번 :** `회원번호`가 고유하지 않은 경우, **서브쿼리에서 단일 행 반환이 실패**할 수 있어 오류가 발생할 가능성이 있다.
    - **2번  :** `회원번호`가 여러 개여도 `IN` 연산을 사용했으므로 **여러 값을 비교**할 수 있어 정상 작동한다.
    - **3번  :** `EXISTS` 절을 사용하는 방식이 잘못되었다. `EXISTS`는 **반환되는 값 자체가 아니라, 조건이 만족되는지 여부를 확인하는 데 사용**된다.
    - **4번  :** `ALL` 연산자는 서브쿼리의 모든 값과 비교해야 하므로, 단일 값이 아닌 경우 오류가 발생할 수 있다.

### 복원기출 1회 50번

![KakaoTalk_20241108_003149223_02.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/f7511b05-f7b2-446f-8b14-0575185a1028/1fa8effa-bcd0-4505-b4a3-214b21fb4392/KakaoTalk_20241108_003149223_02.jpg)

- 선택한 답 : 3번
- 정답 : 2번

`FIRST` 옵션은 **첫 번째로 만족하는 조건에 따라 INSERT를 수행하고 나머지 조건은 무시**한다

- **WHEN N1 >= 2**: `N1` 값이 2 이상이면 `TABLE1`에 삽입.
- **WHEN N1 >= 3**: `N1` 값이 3 이상이면 `TABLE2`에 삽입 (단, 첫 번째 조건이 만족하지 않을 때만 수행됨).
- **ELSE**: 위의 두 조건이 모두 만족하지 않으면 `TABLE3`에 삽입

---

- **N1 = 1**
    - `WHEN N1 >= 2`: 조건에 맞지 않음.
    - `WHEN N1 >= 3`: 조건에 맞지 않음.
    - **ELSE**: 위의 두 조건이 모두 맞지 않으므로, 이 값은 `TABLE3`에 삽입된다.
- **N1 = 2**
    - `WHEN N1 >= 2`: 조건에 맞음. 따라서 `TABLE1`에 삽입됨.
    - 첫 번째 조건이 만족했으므로 **나머지 조건들은 무시**된다.
- **N1 = 5**
    - `WHEN N1 >= 2`: 조건에 맞음. 따라서 `TABLE1`에 삽입됨.
    - 첫 번째 조건이 만족했으므로 **나머지 조건들은 무시**된다
    

<br>

### 😥추가로 헷갈렸던 것!

1. NATURAL JOIN, USING
    
    
    | 키워드 | 설명 |
    | --- | --- |
    | **INNER JOIN** | 두 테이블에서 조건에 일치하는 행만 선택. `ON` 또는 `USING`과 함께 사용. |
    | **ON** | 조인 조건을 명시하는 절. 서로 다른 컬럼 이름을 가진 테이블도 조인 가능. |
    | **NATURAL JOIN** | 두 테이블에서 동일한 컬럼 이름을 자동으로 매칭하여 조인. 조건을 따로 명시하지 않아도 됨. |
    | **USING** | 두 테이블의 특정 동일한 컬럼을 기준으로 조인. `NATURAL JOIN`과 달리 특정 컬럼만 지정 가능. |
2. 연산자 우선 순위
    
    산술 > 연결 > 비교> IS NULL / LIKE / IN > BETWEEN > NOT > AND > OR



<br>
<br>
<br>
<br>
<br>
